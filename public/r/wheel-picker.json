{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "wheel-picker",
  "type": "registry:component",
  "title": "WheelPicker",
  "description": "iOS-style wheel picker built on Ariakit Composite with smooth scroll-snapping and keyboard navigation",
  "dependencies": [
    "@ariakit/react",
    "class-variance-authority",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/wheel-picker.tsx",
      "content": "'use client';\n\nimport * as Ariakit from '@ariakit/react';\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\n\nconst RESISTANCE = 0.3;\nconst MAX_VELOCITY = 30;\nconst easeOutCubic = (p: number) => (p - 1) ** 3 + 1;\nconst clamp = (value: number, min: number, max: number) =>\n\tMath.max(min, Math.min(value, max));\n\ntype Size = 'sm' | 'md' | 'lg';\n\nconst wheelPickerSizeConfig: Record<\n\tSize,\n\t{ itemHeight: number; widthClass: string }\n> = {\n\tsm: { itemHeight: 20, widthClass: 'w-28' },\n\tmd: { itemHeight: 24, widthClass: 'w-32' },\n\tlg: { itemHeight: 28, widthClass: 'w-36' },\n};\n\nconst wheelPickerVariants = cva(\n\t[\n\t\t'relative isolate rounded-md border border-border bg-card shadow-sm card-highlight',\n\t],\n\t{\n\t\tvariants: {\n\t\t\tsize: {\n\t\t\t\tsm: wheelPickerSizeConfig.sm.widthClass,\n\t\t\t\tmd: wheelPickerSizeConfig.md.widthClass,\n\t\t\t\tlg: wheelPickerSizeConfig.lg.widthClass,\n\t\t\t},\n\t\t\tdisabled: {\n\t\t\t\ttrue: 'pointer-events-none cursor-not-allowed opacity-50',\n\t\t\t\tfalse: '',\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: { size: 'md', disabled: false },\n\t},\n);\n\nconst wheelPickerTrackText = cva(\n\t'flex w-full items-center justify-center px-3 text-center text-foreground/45',\n\t{\n\t\tvariants: {\n\t\t\tsize: { sm: 'text-xs', md: 'text-sm', lg: 'text-base' },\n\t\t},\n\t\tdefaultVariants: { size: 'md' },\n\t},\n);\n\nconst wheelPickerHighlightText = cva(\n\t'flex w-full items-center justify-center px-3 text-center font-medium text-foreground',\n\t{\n\t\tvariants: {\n\t\t\tsize: { sm: 'text-sm', md: 'text-base', lg: 'text-lg' },\n\t\t},\n\t\tdefaultVariants: { size: 'md' },\n\t},\n);\n\nconst wheelPickerFocusRingClasses =\n\t'transition-[box-shadow] ease-out-quad duration-100 group-focus/wheelpicker:rounded-sm group-focus/wheelpicker:ring-1 group-focus/wheelpicker:ring-ring/50 group-focus/wheelpicker:ring-offset-1 group-focus/wheelpicker:ring-offset-ring-offset/50 group-focus-visible/wheelpicker:rounded-sm group-focus-visible/wheelpicker:ring-1 group-focus-visible/wheelpicker:ring-ring/50 group-focus-visible/wheelpicker:ring-offset-1 group-focus-visible/wheelpicker:ring-offset-ring-offset/50';\n\nconst wheelPickerHighlightBand = cva(\n\tcn(\n\t\t'absolute left-1 right-1 top-1/2 flex -translate-y-1/2 items-center justify-center bg-card-muted rounded-sm border border-transparent pointer-events-none',\n\t\twheelPickerFocusRingClasses,\n\t),\n\t{\n\t\tvariants: {\n\t\t\tsize: { sm: 'h-5', md: 'h-6', lg: 'h-7' },\n\t\t},\n\t\tdefaultVariants: { size: 'md' },\n\t},\n);\n\ninterface WheelPickerGroupContextValue {\n\tsize: Size;\n\tdisabled: boolean;\n\titemHeight: number;\n}\n\nconst WheelPickerGroupContext =\n\tReact.createContext<WheelPickerGroupContextValue | null>(null);\n\nexport interface WheelPickerGroupProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tsize?: Size;\n\tdisabled?: boolean;\n\tcontentClassName?: string;\n\tchildren?: React.ReactNode;\n}\n\nexport const WheelPickerGroup: React.FC<WheelPickerGroupProps> = ({\n\tsize = 'md',\n\tdisabled = false,\n\tclassName,\n\tchildren,\n\tcontentClassName,\n\t...props\n}) => {\n\tconst itemHeight = React.useMemo(\n\t\t() =>\n\t\t\twheelPickerSizeConfig[size]?.itemHeight ??\n\t\t\twheelPickerSizeConfig.md.itemHeight,\n\t\t[size],\n\t);\n\n\tconst contextValue = React.useMemo<WheelPickerGroupContextValue>(\n\t\t() => ({ size, disabled, itemHeight }),\n\t\t[size, disabled, itemHeight],\n\t);\n\n\treturn (\n\t\t<WheelPickerGroupContext.Provider value={contextValue}>\n\t\t\t<div\n\t\t\t\t{...props}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'relative isolate flex overflow-hidden rounded-md border border-border bg-card shadow-sm',\n\t\t\t\t\tdisabled ? 'pointer-events-none cursor-not-allowed opacity-50' : '',\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t\taria-disabled={disabled || undefined}\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tclassName=\"pointer-events-none absolute left-1 right-1 top-1/2 z-10 -translate-y-1/2 rounded-sm bg-card\"\n\t\t\t\t\tstyle={{ height: itemHeight }}\n\t\t\t\t\taria-hidden\n\t\t\t\t/>\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(wheelPickerHighlightBand({ size }), 'z-20')}\n\t\t\t\t\tstyle={{ height: itemHeight }}\n\t\t\t\t\taria-hidden\n\t\t\t\t/>\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t'relative z-30 flex w-full flex-row gap-0',\n\t\t\t\t\t\tcontentClassName,\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t{children}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</WheelPickerGroupContext.Provider>\n\t);\n};\n\nexport interface WheelPickerProps\n\textends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'> {\n\tvalue?: string;\n\tdefaultValue?: string;\n\tonValueChange?: (value: string) => void;\n\tdisabled?: boolean;\n\tsize?: Size;\n\tvisibleCount?: number;\n\tinfinite?: boolean;\n\t'aria-label'?: string;\n\tchildren?: React.ReactNode;\n}\n\ntype OptionNode = { value: string; node: React.ReactNode };\n\nexport const WheelPicker: React.FC<WheelPickerProps> = ({\n\tvalue,\n\tdefaultValue,\n\tonValueChange,\n\tdisabled: disabledProp = false,\n\tsize: sizeProp = 'md',\n\tvisibleCount: countProp = 20,\n\tinfinite = false,\n\tclassName = '',\n\tchildren,\n\t'aria-label': ariaLabel,\n\t...props\n}) => {\n\tconst groupContext = React.useContext(WheelPickerGroupContext);\n\tconst grouped = Boolean(groupContext);\n\tconst size = groupContext?.size ?? sizeProp;\n\tconst disabled = Boolean(disabledProp || groupContext?.disabled);\n\n\tconst itemHeight = React.useMemo(\n\t\t() =>\n\t\t\twheelPickerSizeConfig[size]?.itemHeight ??\n\t\t\twheelPickerSizeConfig.md.itemHeight,\n\t\t[size],\n\t);\n\n\tconst options = React.useMemo<OptionNode[]>(() => {\n\t\tconst acc: OptionNode[] = [];\n\t\tReact.Children.forEach(children, (child) => {\n\t\t\tif (!React.isValidElement<WheelPickerItemProps>(child)) return;\n\t\t\tconst val = child.props.value as string | undefined;\n\t\t\tif (val == null) return;\n\t\t\tconst node = child.props.children ?? val;\n\t\t\tacc.push({ value: val, node });\n\t\t});\n\t\treturn acc;\n\t}, [children]);\n\n\tconst isControlled = value !== undefined;\n\tconst [internalValue, setInternalValue] = React.useState<string | undefined>(\n\t\tdefaultValue ?? options[0]?.value,\n\t);\n\tconst selectedValue = isControlled ? value : internalValue;\n\n\tconst uid = React.useId();\n\tconst instancePrefix = React.useMemo(\n\t\t() => `wp-${uid.replace(/[:]/g, '')}`,\n\t\t[uid],\n\t);\n\tconst composite = Ariakit.useCompositeStore({\n\t\torientation: 'vertical',\n\t\tvirtualFocus: true,\n\t\tfocusLoop: infinite,\n\t});\n\tconst [isDragging, setIsDragging] = React.useState(false);\n\n\tconst radius = React.useMemo(() => {\n\t\tconst itemAngle = 360 / countProp;\n\t\treturn itemHeight / Math.tan((itemAngle * Math.PI) / 180);\n\t}, [countProp, itemHeight]);\n\tconst containerHeight = React.useMemo(\n\t\t() => Math.round(radius * 2 + itemHeight * 0.25),\n\t\t[radius, itemHeight],\n\t);\n\tconst quarterCount = React.useMemo(() => {\n\t\tconst raw = countProp >> 2;\n\t\tif (!options.length) return Math.max(1, raw);\n\t\tconst safeRaw = Math.max(1, raw);\n\t\treturn Math.min(safeRaw, options.length);\n\t}, [countProp, options.length]);\n\tconst itemAngle = React.useMemo(() => 360 / countProp, [countProp]);\n\tconst halfItemHeight = itemHeight * 0.5;\n\tconst baseDeceleration = 3 * 10;\n\tconst snapBackDeceleration = 10;\n\n\tconst containerRef = React.useRef<HTMLDivElement>(null);\n\tconst wheelItemsRef = React.useRef<HTMLUListElement>(null);\n\tconst highlightListRef = React.useRef<HTMLUListElement>(null);\n\tconst highlightBandRef = React.useRef<HTMLDivElement>(null);\n\n\tconst scrollRef = React.useRef(0);\n\tconst moveId = React.useRef(0);\n\tconst draggingRef = React.useRef(false);\n\tconst hasActiveGestureRef = React.useRef(false);\n\tconst lastWheelTimeRef = React.useRef(0);\n\tconst touchDataRef = React.useRef<{\n\t\tstartY: number;\n\t\tyList: [number, number][];\n\t\ttouchScroll?: number;\n\t\tisClick?: boolean;\n\t}>({ startY: 0, yList: [], touchScroll: 0, isClick: true });\n\tconst dragControllerRef = React.useRef<AbortController | null>(null);\n\tconst selectedValueRef = React.useRef<string | undefined>(selectedValue);\n\n\tconst normalizeScroll = React.useCallback(\n\t\t(scroll: number) =>\n\t\t\t((scroll % options.length) + options.length) % options.length,\n\t\t[options.length],\n\t);\n\n\tconst scrollTo = React.useCallback(\n\t\t(scroll: number) => {\n\t\t\tconst normalizedScroll = infinite ? normalizeScroll(scroll) : scroll;\n\n\t\t\tif (wheelItemsRef.current) {\n\t\t\t\tconst transform = `translateZ(${-radius}px) rotateX(${itemAngle * normalizedScroll}deg)`;\n\t\t\t\twheelItemsRef.current.style.transform = transform;\n\t\t\t\twheelItemsRef.current.childNodes.forEach((node) => {\n\t\t\t\t\tconst li = node as HTMLLIElement;\n\t\t\t\t\t// biome-ignore lint/complexity/useLiteralKeys: DOMStringMap only exposes bracket accessors\n\t\t\t\t\tconst rawIndex = li.dataset?.['index'];\n\t\t\t\t\tif (rawIndex === undefined) return;\n\t\t\t\t\tconst distance = Math.abs(Number(rawIndex) - normalizedScroll);\n\t\t\t\t\tconst hideForDepth = distance > quarterCount;\n\t\t\t\t\tli.style.visibility = hideForDepth ? 'hidden' : 'visible';\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (highlightListRef.current) {\n\t\t\t\tconst transformValue = `translateY(${-normalizedScroll * itemHeight}px)`;\n\t\t\t\thighlightListRef.current.style.transform = transformValue;\n\t\t\t}\n\n\t\t\treturn normalizedScroll;\n\t\t},\n\t\t[infinite, normalizeScroll, radius, itemAngle, quarterCount, itemHeight],\n\t);\n\n\tconst cancelAnimation = React.useCallback(() => {\n\t\tcancelAnimationFrame(moveId.current);\n\t}, []);\n\n\tconst animateScroll = React.useCallback(\n\t\t(\n\t\t\tstartScroll: number,\n\t\t\tendScroll: number,\n\t\t\tduration: number,\n\t\t\tonComplete?: () => void,\n\t\t) => {\n\t\t\tif (duration <= 0 || startScroll === endScroll) {\n\t\t\t\tcancelAnimation();\n\t\t\t\tscrollRef.current = scrollTo(endScroll);\n\t\t\t\tonComplete?.();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst startTime = performance.now();\n\t\t\tconst totalDistance = endScroll - startScroll;\n\t\t\tconst tick = (currentTime: number) => {\n\t\t\t\tconst elapsed = (currentTime - startTime) / 1000;\n\t\t\t\tif (elapsed < duration) {\n\t\t\t\t\tconst progress = easeOutCubic(elapsed / duration);\n\t\t\t\t\tscrollRef.current = scrollTo(startScroll + progress * totalDistance);\n\t\t\t\t\tmoveId.current = requestAnimationFrame(tick);\n\t\t\t\t} else {\n\t\t\t\t\tcancelAnimation();\n\t\t\t\t\tscrollRef.current = scrollTo(endScroll);\n\t\t\t\t\tonComplete?.();\n\t\t\t\t}\n\t\t\t};\n\t\t\trequestAnimationFrame(tick);\n\t\t},\n\t\t[scrollTo, cancelAnimation],\n\t);\n\n\tconst setSelectedValue = React.useCallback(\n\t\t(next: string) => {\n\t\t\tif (!isControlled) setInternalValue(next);\n\t\t\tonValueChange?.(next);\n\t\t},\n\t\t[isControlled, onValueChange],\n\t);\n\n\tconst selectByScroll = React.useCallback(\n\t\t(scroll: number) => {\n\t\t\tconst normalizedFloat = infinite ? normalizeScroll(scroll) : scroll;\n\t\t\tconst boundedScroll = infinite\n\t\t\t\t? Math.round(normalizedFloat)\n\t\t\t\t: clamp(\n\t\t\t\t\t\tMath.round(normalizedFloat),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tMath.max(0, options.length - 1),\n\t\t\t\t\t);\n\t\t\tscrollRef.current = scrollTo(boundedScroll);\n\t\t\tconst selected = options[scrollRef.current];\n\t\t\tif (selected) {\n\t\t\t\tselectedValueRef.current = selected.value;\n\t\t\t\tsetSelectedValue(selected.value);\n\t\t\t\tconst nextActiveId = `${instancePrefix}-${selected.value}`;\n\t\t\t\tif (composite.getState().activeId !== nextActiveId)\n\t\t\t\t\tcomposite.setActiveId(nextActiveId);\n\t\t\t}\n\t\t},\n\t\t[\n\t\t\tinfinite,\n\t\t\tnormalizeScroll,\n\t\t\toptions,\n\t\t\tscrollTo,\n\t\t\tsetSelectedValue,\n\t\t\tcomposite,\n\t\t\tinstancePrefix,\n\t\t],\n\t);\n\n\tconst selectByValue = React.useCallback(\n\t\t(val: string) => {\n\t\t\tconst index = options.findIndex((o) => o.value === val);\n\t\t\tif (index === -1) return;\n\t\t\tcancelAnimation();\n\t\t\tselectByScroll(index);\n\t\t},\n\t\t[options, cancelAnimation, selectByScroll],\n\t);\n\n\tconst scrollByStep = React.useCallback(\n\t\t(step: number) => {\n\t\t\tconst startScroll = scrollRef.current;\n\t\t\tlet endScroll = startScroll + step;\n\t\t\tendScroll = infinite\n\t\t\t\t? Math.round(endScroll)\n\t\t\t\t: clamp(Math.round(endScroll), 0, Math.max(0, options.length - 1));\n\t\t\tconst distance = Math.abs(endScroll - startScroll);\n\t\t\tif (distance === 0) return;\n\t\t\tconst duration = Math.sqrt(distance / 5);\n\t\t\tcancelAnimation();\n\t\t\tanimateScroll(startScroll, endScroll, duration, () =>\n\t\t\t\tselectByScroll(scrollRef.current),\n\t\t\t);\n\t\t},\n\t\t[infinite, options.length, cancelAnimation, animateScroll, selectByScroll],\n\t);\n\n\tconst wheelSegmentPositions = React.useMemo(() => {\n\t\tconst degToRad = Math.PI / 180;\n\t\tconst segmentLengths: number[] = [];\n\t\tfor (let i = quarterCount - 1; i >= -quarterCount + 1; --i) {\n\t\t\tconst angle = i * itemAngle;\n\t\t\tsegmentLengths.push(itemHeight * Math.cos(angle * degToRad));\n\t\t}\n\t\tconst totalLength = segmentLengths.reduce(\n\t\t\t(acc, len) => acc + (len || 0),\n\t\t\t0,\n\t\t);\n\t\tconst startOffset = Math.max(0, (containerHeight - totalLength) / 2);\n\t\tlet positionAlongWheel = startOffset;\n\t\tconst ranges: [number, number][] = [];\n\t\tfor (const length of segmentLengths) {\n\t\t\tconst start = positionAlongWheel;\n\t\t\tpositionAlongWheel += length || 0;\n\t\t\tranges.push([start, positionAlongWheel]);\n\t\t}\n\t\tif (!ranges.length) return ranges;\n\t\tconst first = ranges[0];\n\t\tconst last = ranges[ranges.length - 1];\n\t\tif (first) ranges[0] = [0, first[1]];\n\t\tif (last) ranges[ranges.length - 1] = [last[0], containerHeight];\n\t\treturn ranges;\n\t}, [itemAngle, itemHeight, quarterCount, containerHeight]);\n\n\tconst updateScrollDuringDrag = React.useCallback(\n\t\t(e: MouseEvent | TouchEvent) => {\n\t\t\ttry {\n\t\t\t\tconst currentY =\n\t\t\t\t\t(e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\n\t\t\t\tconst touchData = touchDataRef.current;\n\t\t\t\tif (touchData.isClick) {\n\t\t\t\t\tconst dragThreshold = 5;\n\t\t\t\t\tif (Math.abs(currentY - touchData.startY) > dragThreshold)\n\t\t\t\t\t\ttouchData.isClick = false;\n\t\t\t\t}\n\t\t\t\ttouchData.yList.push([currentY, Date.now()]);\n\t\t\t\tif (touchData.yList.length > 5) touchData.yList.shift();\n\t\t\t\tconst dragDelta = (touchData.startY - currentY) / itemHeight;\n\t\t\t\tlet nextScroll = scrollRef.current + dragDelta;\n\t\t\t\tif (infinite) {\n\t\t\t\t\tnextScroll = normalizeScroll(nextScroll);\n\t\t\t\t} else {\n\t\t\t\t\tconst maxIndex = options.length;\n\t\t\t\t\tif (nextScroll < 0) nextScroll *= RESISTANCE;\n\t\t\t\t\telse if (nextScroll > maxIndex)\n\t\t\t\t\t\tnextScroll = maxIndex + (nextScroll - maxIndex) * RESISTANCE;\n\t\t\t\t}\n\t\t\t\ttouchData.touchScroll = scrollTo(nextScroll);\n\t\t\t} catch {}\n\t\t},\n\t\t[itemHeight, infinite, options.length, normalizeScroll, scrollTo],\n\t);\n\n\tconst handleDragMoveEvent = React.useCallback(\n\t\t(event: MouseEvent | TouchEvent) => {\n\t\t\tif (\n\t\t\t\t!draggingRef.current &&\n\t\t\t\t!containerRef.current?.contains(event.target as Node) &&\n\t\t\t\tevent.target !== containerRef.current\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdraggingRef.current = true;\n\t\t\tupdateScrollDuringDrag(event);\n\t\t},\n\t\t[updateScrollDuringDrag],\n\t);\n\n\tconst initiateDragGesture = React.useCallback(\n\t\t(event: MouseEvent | TouchEvent) => {\n\t\t\tif (hasActiveGestureRef.current) return;\n\t\t\tcancelAnimation();\n\t\t\tconst touchData = touchDataRef.current;\n\t\t\tconst startY =\n\t\t\t\tevent instanceof MouseEvent\n\t\t\t\t\t? event.clientY\n\t\t\t\t\t: event.touches?.[0]?.clientY || 0;\n\t\t\ttouchData.startY = startY;\n\t\t\ttouchData.yList = [];\n\t\t\ttouchData.isClick = true;\n\t\t\ttouchData.touchScroll = scrollRef.current;\n\t\t\thasActiveGestureRef.current = true;\n\t\t\tdraggingRef.current = true;\n\t\t\tsetIsDragging(true);\n\n\t\t\tconst passiveOpts = { passive: false } as const;\n\t\t\tconst controller = new AbortController();\n\t\t\tdragControllerRef.current = controller;\n\t\t\tconst onMouseMove = (e: MouseEvent) => handleDragMoveEvent(e);\n\t\t\tconst onTouchMove = (e: TouchEvent) => handleDragMoveEvent(e);\n\t\t\tconst onMouseLeave = () => controller.abort();\n\t\t\tconst onTouchCancel = () => controller.abort();\n\t\t\tdocument.addEventListener('mousemove', onMouseMove, passiveOpts);\n\t\t\tdocument.addEventListener('touchmove', onTouchMove, passiveOpts);\n\t\t\tdocument.addEventListener('mouseleave', onMouseLeave, passiveOpts);\n\t\t\tdocument.addEventListener('touchcancel', onTouchCancel, passiveOpts);\n\t\t\tcontroller.signal.addEventListener('abort', () => {\n\t\t\t\tdocument.removeEventListener('mousemove', onMouseMove);\n\t\t\t\tdocument.removeEventListener('touchmove', onTouchMove);\n\t\t\t\tdocument.removeEventListener('mouseleave', onMouseLeave);\n\t\t\t\tdocument.removeEventListener('touchcancel', onTouchCancel);\n\t\t\t\tdraggingRef.current = false;\n\t\t\t\thasActiveGestureRef.current = false;\n\t\t\t\tsetIsDragging(false);\n\t\t\t});\n\t\t},\n\t\t[cancelAnimation, handleDragMoveEvent],\n\t);\n\n\tconst handleWheelItemClick = React.useCallback(\n\t\t(clientY: number) => {\n\t\t\tconst container = containerRef.current;\n\t\t\tif (!container) return;\n\t\t\tconst { top, height } = container.getBoundingClientRect();\n\t\t\tconst clickOffsetY = clientY - top;\n\t\t\tconst clickedSegmentIndex = wheelSegmentPositions.findIndex(\n\t\t\t\t([start, end]) => clickOffsetY >= start && clickOffsetY <= end,\n\t\t\t);\n\t\t\tif (clickedSegmentIndex !== -1) {\n\t\t\t\tconst stepsToScroll = (quarterCount - clickedSegmentIndex - 1) * -1;\n\t\t\t\tscrollByStep(stepsToScroll);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst relativeOffset = clickOffsetY - height / 2;\n\t\t\tconst approximateSteps = Math.round(relativeOffset / itemHeight);\n\t\t\tif (approximateSteps !== 0) scrollByStep(approximateSteps);\n\t\t},\n\t\t[wheelSegmentPositions, quarterCount, scrollByStep, itemHeight],\n\t);\n\n\tconst decelerateAndAnimateScroll = React.useCallback(\n\t\t(initialVelocity: number) => {\n\t\t\tconst currentScroll = scrollRef.current;\n\t\t\tlet targetScroll = currentScroll;\n\t\t\tlet deceleration =\n\t\t\t\tinitialVelocity > 0 ? -baseDeceleration : baseDeceleration;\n\t\t\tlet duration = 0;\n\n\t\t\tif (infinite) {\n\t\t\t\tduration = Math.abs(initialVelocity / deceleration);\n\t\t\t\tconst scrollDistance =\n\t\t\t\t\tinitialVelocity * duration + 0.5 * deceleration * duration * duration;\n\t\t\t\ttargetScroll = Math.round(currentScroll + scrollDistance);\n\t\t\t} else if (currentScroll < 0 || currentScroll > options.length - 1) {\n\t\t\t\tconst target = clamp(currentScroll, 0, Math.max(0, options.length - 1));\n\t\t\t\tconst scrollDistance = currentScroll - target;\n\t\t\t\tdeceleration = snapBackDeceleration;\n\t\t\t\tduration = Math.sqrt(Math.abs(scrollDistance / deceleration));\n\t\t\t\tinitialVelocity = deceleration * duration;\n\t\t\t\tinitialVelocity =\n\t\t\t\t\tcurrentScroll > 0 ? -initialVelocity : initialVelocity;\n\t\t\t\ttargetScroll = target;\n\t\t\t} else {\n\t\t\t\tduration = Math.abs(initialVelocity / deceleration);\n\t\t\t\tconst scrollDistance =\n\t\t\t\t\tinitialVelocity * duration + 0.5 * deceleration * duration * duration;\n\t\t\t\ttargetScroll = Math.round(currentScroll + scrollDistance);\n\t\t\t\ttargetScroll = clamp(targetScroll, 0, Math.max(0, options.length - 1));\n\t\t\t\tconst adjustedDistance = targetScroll - currentScroll;\n\t\t\t\tduration = Math.sqrt(Math.abs(adjustedDistance / deceleration));\n\t\t\t}\n\n\t\t\tanimateScroll(currentScroll, targetScroll, duration, () => {\n\t\t\t\tselectByScroll(scrollRef.current);\n\t\t\t});\n\t\t},\n\t\t[infinite, options.length, animateScroll, selectByScroll],\n\t);\n\n\tconst finalizeDragAndStartInertiaScroll = React.useCallback(() => {\n\t\ttry {\n\t\t\tdragControllerRef.current?.abort();\n\t\t\tdragControllerRef.current = null;\n\t\t\tconst touchData = touchDataRef.current;\n\t\t\tif (touchData.isClick) {\n\t\t\t\thandleWheelItemClick(touchData.startY);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst yList = touchData.yList;\n\t\t\tlet velocity = 0;\n\t\t\tif (yList.length > 1) {\n\t\t\t\tconst len = yList.length;\n\t\t\t\tconst [startY, startTime] = yList[len - 2] ?? [0, 0];\n\t\t\t\tconst [endY, endTime] = yList[len - 1] ?? [0, 0];\n\t\t\t\tconst timeDiff = endTime - startTime;\n\t\t\t\tif (timeDiff > 0) {\n\t\t\t\t\tconst distance = startY - endY;\n\t\t\t\t\tconst velocityPerSecond = ((distance / itemHeight) * 1000) / timeDiff;\n\t\t\t\t\tconst direction = velocityPerSecond > 0 ? 1 : -1;\n\t\t\t\t\tconst absVelocity = Math.min(\n\t\t\t\t\t\tMath.abs(velocityPerSecond),\n\t\t\t\t\t\tMAX_VELOCITY,\n\t\t\t\t\t);\n\t\t\t\t\tvelocity = absVelocity * direction;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscrollRef.current = touchData.touchScroll ?? scrollRef.current;\n\t\t\tdecelerateAndAnimateScroll(velocity);\n\t\t} finally {\n\t\t\tdraggingRef.current = false;\n\t\t\thasActiveGestureRef.current = false;\n\t\t\tsetIsDragging(false);\n\t\t}\n\t}, [itemHeight, handleWheelItemClick, decelerateAndAnimateScroll]);\n\n\tconst handleDragStartEvent = React.useCallback(\n\t\t(e: MouseEvent | TouchEvent) => {\n\t\t\tconst isDragging = draggingRef.current;\n\t\t\tconst isTargetValid =\n\t\t\t\t!!containerRef.current?.contains(e.target as Node) ||\n\t\t\t\te.target === containerRef.current;\n\t\t\tif ((isDragging || isTargetValid) && e.cancelable) {\n\t\t\t\te.preventDefault?.();\n\t\t\t\tif (options.length) initiateDragGesture(e);\n\t\t\t}\n\t\t},\n\t\t[initiateDragGesture, options.length],\n\t);\n\n\tconst scrollByWheel = React.useCallback(\n\t\t(event: WheelEvent) => {\n\t\t\tevent.preventDefault();\n\t\t\tconst now = Date.now();\n\t\t\tif (now - lastWheelTimeRef.current < 100) return;\n\t\t\tconst direction = Math.sign(event.deltaY);\n\t\t\tif (!direction) return;\n\t\t\tlastWheelTimeRef.current = now;\n\t\t\tscrollByStep(direction);\n\t\t},\n\t\t[scrollByStep],\n\t);\n\n\tconst handleWheelEvent = React.useCallback(\n\t\t(event: WheelEvent) => {\n\t\t\tif (!options.length || !containerRef.current) return;\n\t\t\tconst isDragging = draggingRef.current;\n\t\t\tconst isTargetValid =\n\t\t\t\tcontainerRef.current.contains(event.target as Node) ||\n\t\t\t\tevent.target === containerRef.current;\n\t\t\tif ((isDragging || isTargetValid) && event.cancelable) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tscrollByWheel(event);\n\t\t\t}\n\t\t},\n\t\t[scrollByWheel, options.length],\n\t);\n\n\tReact.useEffect(() => {\n\t\tconst container = containerRef.current;\n\t\tif (!container) return;\n\t\tconst opts = { passive: false } as const;\n\t\tconst onTouchEnd = (e: Event) => {\n\t\t\tif (!hasActiveGestureRef.current) return;\n\t\t\te.cancelable && e.preventDefault();\n\t\t\tfinalizeDragAndStartInertiaScroll();\n\t\t};\n\t\tconst onMouseUp = (e: Event) => {\n\t\t\tif (!hasActiveGestureRef.current) return;\n\t\t\te.cancelable && e.preventDefault();\n\t\t\tfinalizeDragAndStartInertiaScroll();\n\t\t};\n\t\tcontainer.addEventListener(\n\t\t\t'touchstart',\n\t\t\thandleDragStartEvent as (e: Event) => void,\n\t\t\topts,\n\t\t);\n\t\tcontainer.addEventListener('touchend', onTouchEnd, opts);\n\t\tcontainer.addEventListener(\n\t\t\t'wheel',\n\t\t\thandleWheelEvent as (e: Event) => void,\n\t\t\topts,\n\t\t);\n\t\tdocument.addEventListener(\n\t\t\t'mousedown',\n\t\t\thandleDragStartEvent as (e: Event) => void,\n\t\t\topts,\n\t\t);\n\t\tdocument.addEventListener('mouseup', onMouseUp, opts);\n\t\treturn () => {\n\t\t\tcontainer.removeEventListener(\n\t\t\t\t'touchstart',\n\t\t\t\thandleDragStartEvent as (e: Event) => void,\n\t\t\t);\n\t\t\tcontainer.removeEventListener(\n\t\t\t\t'touchend',\n\t\t\t\tonTouchEnd as (e: Event) => void,\n\t\t\t);\n\t\t\tcontainer.removeEventListener(\n\t\t\t\t'wheel',\n\t\t\t\thandleWheelEvent as (e: Event) => void,\n\t\t\t);\n\t\t\tdocument.removeEventListener(\n\t\t\t\t'mousedown',\n\t\t\t\thandleDragStartEvent as (e: Event) => void,\n\t\t\t);\n\t\t\tdocument.removeEventListener('mouseup', onMouseUp as (e: Event) => void);\n\t\t};\n\t}, [\n\t\thandleDragStartEvent,\n\t\tfinalizeDragAndStartInertiaScroll,\n\t\thandleWheelEvent,\n\t]);\n\n\tReact.useEffect(() => {\n\t\tif (!options.length) return;\n\t\tconst val = selectedValue ?? options[0]?.value;\n\t\tif (val != null) selectByValue(val);\n\t}, [selectedValue, options, selectByValue]);\n\n\tconst renderWheelItems = React.useMemo(() => {\n\t\tconst items: React.ReactNode[] = [];\n\t\tconst renderItem = (opt: OptionNode, idx: number, angle: number) => (\n\t\t\t<li\n\t\t\t\tkey={idx}\n\t\t\t\tdata-index={idx}\n\t\t\t\tclassName={wheelPickerTrackText({ size })}\n\t\t\t\tstyle={{\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\ttop: -halfItemHeight,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: itemHeight,\n\t\t\t\t\tWebkitFontSmoothing: 'subpixel-antialiased',\n\t\t\t\t\twillChange: 'visibility',\n\t\t\t\t\ttransform: `rotateX(${angle}deg) translateZ(${radius}px)`,\n\t\t\t\t\tvisibility: 'hidden',\n\t\t\t\t}}\n\t\t\t\taria-hidden\n\t\t\t>\n\t\t\t\t{opt.node}\n\t\t\t</li>\n\t\t);\n\n\t\tfor (let i = 0; i < options.length; i++) {\n\t\t\tconst option = options[i];\n\t\t\tif (!option) continue;\n\t\t\titems.push(renderItem(option, i, -itemAngle * i));\n\t\t}\n\n\t\tif (infinite) {\n\t\t\tfor (let i = 0; i < quarterCount; i++) {\n\t\t\t\tconst prependIndex = -i - 1;\n\t\t\t\tconst appendIndex = i + options.length;\n\t\t\t\tconst prependOption = options[options.length - i - 1];\n\t\t\t\tconst appendOption = options[i];\n\t\t\t\tif (prependOption) {\n\t\t\t\t\titems.unshift(\n\t\t\t\t\t\trenderItem(prependOption, prependIndex, itemAngle * (i + 1)),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (appendOption) {\n\t\t\t\t\titems.push(\n\t\t\t\t\t\trenderItem(appendOption, appendIndex, -itemAngle * appendIndex),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}, [\n\t\toptions,\n\t\titemAngle,\n\t\titemHeight,\n\t\thalfItemHeight,\n\t\tradius,\n\t\tsize,\n\t\tquarterCount,\n\t\tinfinite,\n\t]);\n\n\tconst renderHighlightItems = React.useMemo(() => {\n\t\tconst items = options.map((opt) => (\n\t\t\t<Ariakit.CompositeItem\n\t\t\t\tstore={composite}\n\t\t\t\tkey={opt.value}\n\t\t\t\tid={`${instancePrefix}-${opt.value}`}\n\t\t\t\tclassName={wheelPickerHighlightText({ size })}\n\t\t\t\tstyle={{ height: itemHeight }}\n\t\t\t>\n\t\t\t\t{opt.node}\n\t\t\t</Ariakit.CompositeItem>\n\t\t));\n\t\tif (infinite && options.length) {\n\t\t\titems.unshift(\n\t\t\t\t<li\n\t\t\t\t\tkey=\"infinite-start\"\n\t\t\t\t\tclassName={wheelPickerHighlightText({ size })}\n\t\t\t\t\tstyle={{ height: itemHeight }}\n\t\t\t\t>\n\t\t\t\t\t{options[options.length - 1]?.node}\n\t\t\t\t</li>,\n\t\t\t);\n\t\t\titems.push(\n\t\t\t\t<li\n\t\t\t\t\tkey=\"infinite-end\"\n\t\t\t\t\tclassName={wheelPickerHighlightText({ size })}\n\t\t\t\t\tstyle={{ height: itemHeight }}\n\t\t\t\t>\n\t\t\t\t\t{options[0]?.node}\n\t\t\t\t</li>,\n\t\t\t);\n\t\t}\n\t\treturn items;\n\t}, [options, infinite, size, itemHeight, instancePrefix, composite]);\n\n\tconst rootClassName = grouped\n\t\t? cn(\n\t\t\t\t'relative isolate flex-none min-w-0 overflow-hidden bg-transparent shadow-none',\n\t\t\t\twheelPickerSizeConfig[size]?.widthClass,\n\t\t\t\tdisabled && 'pointer-events-none cursor-not-allowed opacity-50',\n\t\t\t\tclassName,\n\t\t\t)\n\t\t: cn(wheelPickerVariants({ size, disabled }), className);\n\n\tconst activeIndex = React.useMemo(\n\t\t() => options.findIndex((o) => o.value === selectedValue),\n\t\t[options, selectedValue],\n\t);\n\tconst activeId =\n\t\tactiveIndex >= 0 && options[activeIndex]\n\t\t\t? `${instancePrefix}-${options[activeIndex]?.value}`\n\t\t\t: undefined;\n\n\tReact.useEffect(() => {\n\t\tif (!activeId) return;\n\t\tif (composite.getState().activeId !== activeId)\n\t\t\tcomposite.setActiveId(activeId);\n\t}, [activeId, composite]);\n\n\tconst ariakitActiveId = Ariakit.useStoreState(composite, (s) => s.activeId);\n\n\tReact.useEffect(() => {\n\t\tif (!ariakitActiveId) return;\n\t\tconst idx = options.findIndex(\n\t\t\t(o) => `${instancePrefix}-${o.value}` === ariakitActiveId,\n\t\t);\n\n\t\tif (idx < 0) return;\n\n\t\tconst start = scrollRef.current;\n\t\tlet end = infinite ? idx : clamp(idx, 0, Math.max(0, options.length - 1));\n\n\t\tif (infinite && options.length) {\n\t\t\tconst length = options.length;\n\t\t\tconst diff = end - start;\n\t\t\tif (diff > length / 2) end -= length;\n\t\t\telse if (diff < -length / 2) end += length;\n\t\t}\n\n\t\tif (start === end) {\n\t\t\tscrollRef.current = scrollTo(end);\n\t\t\tselectByScroll(scrollRef.current);\n\t\t\treturn;\n\t\t}\n\n\t\tconst distance = Math.abs(end - start);\n\t\tconst duration = Math.sqrt(distance / 5);\n\n\t\tcancelAnimation();\n\t\tanimateScroll(start, end, duration, () =>\n\t\t\tselectByScroll(scrollRef.current),\n\t\t);\n\t}, [\n\t\tariakitActiveId,\n\t\toptions,\n\t\tinstancePrefix,\n\t\tinfinite,\n\t\tcancelAnimation,\n\t\tanimateScroll,\n\t\tselectByScroll,\n\t\tscrollTo,\n\t]);\n\n\treturn (\n\t\t<div\n\t\t\t{...props}\n\t\t\tclassName={rootClassName}\n\t\t\taria-disabled={disabled || undefined}\n\t\t>\n\t\t\t<Ariakit.Composite\n\t\t\t\tref={containerRef}\n\t\t\t\tstore={composite}\n\t\t\t\trole=\"listbox\"\n\t\t\t\taria-label={ariaLabel}\n\t\t\t\ttabIndex={disabled ? -1 : 0}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'group/wheelpicker relative flex h-full w-full select-none outline-none focus-visible:outline-none',\n\t\t\t\t\tdisabled\n\t\t\t\t\t\t? 'cursor-not-allowed'\n\t\t\t\t\t\t: isDragging\n\t\t\t\t\t\t\t? 'cursor-grabbing'\n\t\t\t\t\t\t\t: 'cursor-grab',\n\t\t\t\t)}\n\t\t\t\tstyle={{\n\t\t\t\t\theight: containerHeight,\n\t\t\t\t\tperspective: '2000px',\n\t\t\t\t\tuserSelect: 'none',\n\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\tWebkitMaskImage:\n\t\t\t\t\t\t'linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%)',\n\t\t\t\t\tmaskImage:\n\t\t\t\t\t\t'linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%)',\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<ul\n\t\t\t\t\tref={wheelItemsRef}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\t\ttop: '50%',\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tdisplay: 'block',\n\t\t\t\t\t\twidth: '100%',\n\t\t\t\t\t\theight: 0,\n\t\t\t\t\t\tmargin: '0 auto',\n\t\t\t\t\t\tWebkitFontSmoothing: 'subpixel-antialiased',\n\t\t\t\t\t\twillChange: 'transform',\n\t\t\t\t\t\tbackfaceVisibility: 'hidden',\n\t\t\t\t\t\ttransformStyle: 'preserve-3d',\n\t\t\t\t\t}}\n\t\t\t\t\taria-hidden\n\t\t\t\t>\n\t\t\t\t\t{renderWheelItems}\n\t\t\t\t</ul>\n\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t'pointer-events-none absolute left-0 top-1/2 w-full -translate-y-1/2 rounded-none bg-card',\n\t\t\t\t\t\tgrouped && 'rounded-none bg-transparent',\n\t\t\t\t\t)}\n\t\t\t\t\tstyle={{ height: itemHeight, borderRadius: grouped ? 0 : 'inherit' }}\n\t\t\t\t\taria-hidden\n\t\t\t\t/>\n\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\twheelPickerHighlightBand({ size }),\n\t\t\t\t\t\tgrouped && 'left-1 right-1 rounded-sm z-40',\n\t\t\t\t\t)}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\toverflow: 'clip',\n\t\t\t\t\t\theight: itemHeight,\n\t\t\t\t\t}}\n\t\t\t\t\tref={highlightBandRef}\n\t\t\t\t>\n\t\t\t\t\t<ul\n\t\t\t\t\t\tref={highlightListRef}\n\t\t\t\t\t\tclassName=\"m-0 w-full list-none p-0\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\t\t\twidth: '100%',\n\t\t\t\t\t\t\ttop: infinite ? -itemHeight - 1 : -1,\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\tpointerEvents: 'none',\n\t\t\t\t\t\t\toverflow: 'visible',\n\t\t\t\t\t\t\tscrollMargin: '0px',\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{renderHighlightItems}\n\t\t\t\t\t</ul>\n\t\t\t\t</div>\n\t\t\t</Ariakit.Composite>\n\t\t</div>\n\t);\n};\n\nexport interface WheelPickerItemProps\n\textends Omit<React.HTMLAttributes<HTMLDivElement>, 'value'> {\n\tvalue: string;\n\tchildren?: React.ReactNode;\n}\n\nexport const WheelPickerItem: React.FC<WheelPickerItemProps> = () => null;\n\nexport type { VariantProps };\n",
      "type": "registry:component"
    }
  ]
}