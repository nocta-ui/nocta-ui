{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "scroll-area",
  "type": "registry:component",
  "title": "Scroll Area",
  "description": "A stylized scroll container with composable viewport, custom indicators, and hover or scroll-driven visibility",
  "dependencies": [
    "class-variance-authority",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/scroll-area.tsx",
      "content": "'use client';\n\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\n\ntype ScrollAreaType = 'hover' | 'scroll' | 'always';\ntype ScrollAxis = 'vertical' | 'horizontal';\ntype ScrollDirection = ScrollAxis | 'both';\n\ninterface ScrollMetrics {\n\tsize: number;\n\tprogress: number;\n\tscrollable: boolean;\n}\n\ninterface ScrollAreaContextValue {\n\tscrollAreaRef: React.RefObject<HTMLDivElement | null>;\n\tviewportRef: React.RefObject<HTMLDivElement | null>;\n\ttype: ScrollAreaType;\n\tscrollHideDelay: number;\n\tscrollbarThumbClassName: string | undefined;\n}\n\nconst ScrollAreaContext = React.createContext<ScrollAreaContextValue | null>(\n\tnull,\n);\n\nconst scrollAreaBaseClass = 'group/scroll-area relative overflow-hidden';\n\nconst scrollViewportBaseClass =\n\t'relative size-full overflow-auto [scrollbar-width:none] [-ms-overflow-style:none] [&::-webkit-scrollbar]:hidden';\n\nconst scrollBarVariants = cva(\n\t'pointer-events-none absolute z-20 select-none rounded-full bg-transparent opacity-0 transition-opacity duration-300 ease-smooth overflow-hidden',\n\t{\n\t\tvariants: {\n\t\t\torientation: {\n\t\t\t\tvertical: 'right-1 top-1 bottom-1',\n\t\t\t\thorizontal: 'left-1 right-1 bottom-1',\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tsm: '',\n\t\t\t\tmd: '',\n\t\t\t\tlg: '',\n\t\t\t},\n\t\t},\n\t\tcompoundVariants: [\n\t\t\t{ orientation: 'vertical', size: 'sm', class: 'w-1' },\n\t\t\t{ orientation: 'vertical', size: 'md', class: 'w-1.5' },\n\t\t\t{ orientation: 'vertical', size: 'lg', class: 'w-2' },\n\t\t\t{ orientation: 'horizontal', size: 'sm', class: 'h-1' },\n\t\t\t{ orientation: 'horizontal', size: 'md', class: 'h-1.5' },\n\t\t\t{ orientation: 'horizontal', size: 'lg', class: 'h-2' },\n\t\t],\n\t\tdefaultVariants: {\n\t\t\torientation: 'vertical',\n\t\t\tsize: 'md',\n\t\t},\n\t},\n);\n\nconst MIN_THUMB_RATIO = 0.08;\nconst CORNER_GAP = 8;\n\nfunction useScrollAreaContext(component: string) {\n\tconst context = React.useContext(ScrollAreaContext);\n\tif (!context) {\n\t\tthrow new Error(`${component} must be used within <ScrollArea>`);\n\t}\n\treturn context;\n}\n\nfunction calculateAxisMetrics(\n\ttotal: number,\n\tviewport: number,\n\toffset: number,\n): ScrollMetrics {\n\tif (total <= viewport || total === 0) {\n\t\treturn { size: 1, progress: 0, scrollable: false };\n\t}\n\n\tconst size = Math.min(Math.max(viewport / total, 0), 1);\n\tconst maxScroll = total - viewport;\n\tconst progress =\n\t\tmaxScroll > 0 ? Math.min(Math.max(offset / maxScroll, 0), 1) : 0;\n\n\treturn {\n\t\tsize,\n\t\tprogress,\n\t\tscrollable: true,\n\t};\n}\n\nfunction composeRefs<T>(\n\t...refs: Array<React.Ref<T> | undefined>\n): React.RefCallback<T> {\n\treturn (node) => {\n\t\tfor (const ref of refs) {\n\t\t\tif (!ref) continue;\n\t\t\tif (typeof ref === 'function') {\n\t\t\t\tref(node);\n\t\t\t} else {\n\t\t\t\t(ref as React.RefObject<T | null>).current = node;\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport interface ScrollAreaProps\n\textends Omit<React.HTMLAttributes<HTMLDivElement>, 'children'> {\n\tchildren: React.ReactNode;\n\ttype?: ScrollAreaType;\n\tdirection?: ScrollDirection;\n\tonViewportScroll?: React.UIEventHandler<HTMLDivElement>;\n\tscrollbarSize?: VariantProps<typeof scrollBarVariants>['size'];\n\thorizontalScrollbarSize?: VariantProps<typeof scrollBarVariants>['size'];\n\tscrollbarThumbClassName?: string;\n\tscrollHideDelay?: number;\n}\n\nexport const ScrollArea = React.forwardRef<HTMLDivElement, ScrollAreaProps>(\n\t(\n\t\t{\n\t\t\tchildren,\n\t\t\tclassName,\n\t\t\ttype = 'hover',\n\t\t\tdirection = 'vertical',\n\t\t\tonViewportScroll,\n\t\t\tscrollbarSize = 'md',\n\t\t\thorizontalScrollbarSize,\n\t\t\tscrollbarThumbClassName,\n\t\t\tscrollHideDelay = 600,\n\t\t\t...props\n\t\t},\n\t\tref,\n\t) => {\n\t\tconst scrollAreaRef = React.useRef<HTMLDivElement | null>(null);\n\t\tconst viewportRef = React.useRef<HTMLDivElement | null>(null);\n\n\t\tconst composedRef = React.useMemo(\n\t\t\t() => composeRefs(ref, scrollAreaRef),\n\t\t\t[ref],\n\t\t);\n\n\t\tconst contextValue = React.useMemo<ScrollAreaContextValue>(\n\t\t\t() => ({\n\t\t\t\tscrollAreaRef,\n\t\t\t\tviewportRef,\n\t\t\t\ttype,\n\t\t\t\tscrollHideDelay,\n\t\t\t\tscrollbarThumbClassName,\n\t\t\t}),\n\t\t\t[type, scrollHideDelay, scrollbarThumbClassName],\n\t\t);\n\n\t\tconst showVerticalScrollBar =\n\t\t\tdirection === 'vertical' || direction === 'both';\n\t\tconst showHorizontalScrollBar =\n\t\t\tdirection === 'horizontal' || direction === 'both';\n\t\tconst resolvedHorizontalSize = horizontalScrollbarSize ?? scrollbarSize;\n\n\t\treturn (\n\t\t\t<ScrollAreaContext.Provider value={contextValue}>\n\t\t\t\t<div\n\t\t\t\t\tref={composedRef}\n\t\t\t\t\tclassName={cn(scrollAreaBaseClass, className)}\n\t\t\t\t\t{...props}\n\t\t\t\t>\n\t\t\t\t\t<ScrollViewport onScroll={onViewportScroll}>\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</ScrollViewport>\n\t\t\t\t\t{showVerticalScrollBar && (\n\t\t\t\t\t\t<ScrollBar orientation=\"vertical\" size={scrollbarSize} />\n\t\t\t\t\t)}\n\t\t\t\t\t{showHorizontalScrollBar && (\n\t\t\t\t\t\t<ScrollBar orientation=\"horizontal\" size={resolvedHorizontalSize} />\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</ScrollAreaContext.Provider>\n\t\t);\n\t},\n);\nScrollArea.displayName = 'ScrollArea';\n\ninterface ScrollViewportProps extends React.HTMLAttributes<HTMLDivElement> {}\n\nconst ScrollViewport = React.forwardRef<HTMLDivElement, ScrollViewportProps>(\n\t({ className, onScroll, children, ...props }, ref) => {\n\t\tconst { viewportRef } = useScrollAreaContext('ScrollViewport');\n\n\t\tconst composedRef = React.useMemo(\n\t\t\t() => composeRefs(ref, viewportRef),\n\t\t\t[ref, viewportRef],\n\t\t);\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={composedRef}\n\t\t\t\tonScroll={onScroll}\n\t\t\t\tclassName={cn(scrollViewportBaseClass, className)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t</div>\n\t\t);\n\t},\n);\nScrollViewport.displayName = 'ScrollViewport';\n\nexport interface ScrollBarProps\n\textends React.HTMLAttributes<HTMLDivElement>,\n\t\tVariantProps<typeof scrollBarVariants> {\n\torientation?: ScrollAxis;\n}\n\nconst ScrollBar = React.forwardRef<HTMLDivElement, ScrollBarProps>(\n\t(\n\t\t{ className, orientation = 'vertical', size = 'md', style, ...props },\n\t\tref,\n\t) => {\n\t\tconst {\n\t\t\tviewportRef,\n\t\t\tscrollAreaRef,\n\t\t\ttype,\n\t\t\tscrollHideDelay,\n\t\t\tscrollbarThumbClassName,\n\t\t} = useScrollAreaContext('ScrollBar');\n\n\t\tconst scrollbarRef = React.useRef<HTMLDivElement | null>(null);\n\t\tconst thumbRef = React.useRef<HTMLSpanElement | null>(null);\n\t\tconst isScrollableRef = React.useRef(false);\n\n\t\tconst composedRef = React.useMemo(\n\t\t\t() => composeRefs(ref, scrollbarRef),\n\t\t\t[ref],\n\t\t);\n\n\t\tconst updateThumbPosition = React.useCallback(() => {\n\t\t\tconst viewport = viewportRef.current;\n\t\t\tconst thumb = thumbRef.current;\n\t\t\tconst scrollbar = scrollbarRef.current;\n\t\t\tif (!viewport || !thumb || !scrollbar) return;\n\n\t\t\tconst metrics = calculateAxisMetrics(\n\t\t\t\torientation === 'vertical'\n\t\t\t\t\t? viewport.scrollHeight\n\t\t\t\t\t: viewport.scrollWidth,\n\t\t\t\torientation === 'vertical'\n\t\t\t\t\t? viewport.clientHeight\n\t\t\t\t\t: viewport.clientWidth,\n\t\t\t\torientation === 'vertical' ? viewport.scrollTop : viewport.scrollLeft,\n\t\t\t);\n\n\t\t\tconst wasScrollable = isScrollableRef.current;\n\t\t\tisScrollableRef.current = metrics.scrollable;\n\n\t\t\tif (metrics.scrollable && !wasScrollable) {\n\t\t\t\tscrollbar.style.display = '';\n\t\t\t} else if (!metrics.scrollable && wasScrollable) {\n\t\t\t\tscrollbar.style.display = 'none';\n\t\t\t}\n\n\t\t\tif (metrics.scrollable) {\n\t\t\t\tconst thumbFraction = Math.max(metrics.size, MIN_THUMB_RATIO);\n\t\t\t\tconst thumbSizePercent = thumbFraction * 100;\n\t\t\t\tconst maxOffset = Math.max(0, 100 - thumbSizePercent);\n\t\t\t\tconst offsetPercent = metrics.progress * maxOffset;\n\n\t\t\t\tif (orientation === 'vertical') {\n\t\t\t\t\tthumb.style.height = `${thumbSizePercent}%`;\n\t\t\t\t\tthumb.style.top = `${offsetPercent}%`;\n\t\t\t\t} else {\n\t\t\t\t\tthumb.style.width = `${thumbSizePercent}%`;\n\t\t\t\t\tthumb.style.left = `${offsetPercent}%`;\n\t\t\t\t}\n\t\t\t}\n\t\t}, [orientation, viewportRef]);\n\n\t\tReact.useEffect(() => {\n\t\t\tconst scrollbar = scrollbarRef.current;\n\t\t\tif (!scrollbar) return;\n\n\t\t\tif (type === 'always') {\n\t\t\t\tscrollbar.style.opacity = '1';\n\t\t\t}\n\t\t}, [type]);\n\n\t\tReact.useEffect(() => {\n\t\t\tif (type !== 'hover') return;\n\n\t\t\tconst scrollArea = scrollAreaRef.current;\n\t\t\tconst scrollbar = scrollbarRef.current;\n\t\t\tif (!scrollArea || !scrollbar) return;\n\n\t\t\tlet hideTimer: number | undefined;\n\n\t\t\tconst show = () => {\n\t\t\t\tif (hideTimer !== undefined) {\n\t\t\t\t\twindow.clearTimeout(hideTimer);\n\t\t\t\t}\n\t\t\t\tscrollbar.style.opacity = '1';\n\t\t\t};\n\n\t\t\tconst hide = () => {\n\t\t\t\thideTimer = window.setTimeout(() => {\n\t\t\t\t\tscrollbar.style.opacity = '0';\n\t\t\t\t}, scrollHideDelay);\n\t\t\t};\n\n\t\t\tscrollArea.addEventListener('pointerenter', show);\n\t\t\tscrollArea.addEventListener('pointerleave', hide);\n\n\t\t\treturn () => {\n\t\t\t\tif (hideTimer !== undefined) {\n\t\t\t\t\twindow.clearTimeout(hideTimer);\n\t\t\t\t}\n\t\t\t\tscrollArea.removeEventListener('pointerenter', show);\n\t\t\t\tscrollArea.removeEventListener('pointerleave', hide);\n\t\t\t};\n\t\t}, [type, scrollHideDelay, scrollAreaRef]);\n\n\t\tReact.useEffect(() => {\n\t\t\tif (type !== 'scroll') return;\n\n\t\t\tconst viewport = viewportRef.current;\n\t\t\tconst scrollbar = scrollbarRef.current;\n\t\t\tif (!viewport || !scrollbar) return;\n\n\t\t\tlet hideTimer: number | undefined;\n\n\t\t\tconst handleScroll = () => {\n\t\t\t\tscrollbar.style.opacity = '1';\n\n\t\t\t\tif (hideTimer !== undefined) {\n\t\t\t\t\twindow.clearTimeout(hideTimer);\n\t\t\t\t}\n\n\t\t\t\thideTimer = window.setTimeout(() => {\n\t\t\t\t\tscrollbar.style.opacity = '0';\n\t\t\t\t}, scrollHideDelay);\n\n\t\t\t\trequestAnimationFrame(updateThumbPosition);\n\t\t\t};\n\n\t\t\tviewport.addEventListener('scroll', handleScroll, { passive: true });\n\n\t\t\treturn () => {\n\t\t\t\tif (hideTimer !== undefined) {\n\t\t\t\t\twindow.clearTimeout(hideTimer);\n\t\t\t\t}\n\t\t\t\tviewport.removeEventListener('scroll', handleScroll);\n\t\t\t};\n\t\t}, [type, scrollHideDelay, viewportRef, updateThumbPosition]);\n\n\t\tReact.useEffect(() => {\n\t\t\tconst viewport = viewportRef.current;\n\t\t\tif (!viewport) return;\n\n\t\t\tupdateThumbPosition();\n\n\t\t\tconst handleScroll = () => {\n\t\t\t\trequestAnimationFrame(updateThumbPosition);\n\t\t\t};\n\n\t\t\tviewport.addEventListener('scroll', handleScroll, { passive: true });\n\n\t\t\tconst resizeObserver = new ResizeObserver(() => {\n\t\t\t\trequestAnimationFrame(updateThumbPosition);\n\t\t\t});\n\t\t\tresizeObserver.observe(viewport);\n\n\t\t\treturn () => {\n\t\t\t\tviewport.removeEventListener('scroll', handleScroll);\n\t\t\t\tresizeObserver.disconnect();\n\t\t\t};\n\t\t}, [viewportRef, updateThumbPosition]);\n\n\t\tconst viewport = viewportRef.current;\n\t\tconst hasBoth =\n\t\t\tviewport &&\n\t\t\tviewport.scrollHeight > viewport.clientHeight &&\n\t\t\tviewport.scrollWidth > viewport.clientWidth;\n\n\t\tconst trackStyle =\n\t\t\thasBoth && orientation === 'vertical'\n\t\t\t\t? { bottom: `calc(0.25rem + ${CORNER_GAP}px)` }\n\t\t\t\t: hasBoth && orientation === 'horizontal'\n\t\t\t\t\t? { right: `calc(0.25rem + ${CORNER_GAP}px)` }\n\t\t\t\t\t: undefined;\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={composedRef}\n\t\t\t\taria-hidden=\"true\"\n\t\t\t\tdata-orientation={orientation}\n\t\t\t\tclassName={cn(scrollBarVariants({ orientation, size }), className)}\n\t\t\t\tstyle={{\n\t\t\t\t\tdisplay: 'none',\n\t\t\t\t\t...(trackStyle ? trackStyle : {}),\n\t\t\t\t\t...style,\n\t\t\t\t}}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t<span\n\t\t\t\t\tref={thumbRef}\n\t\t\t\t\taria-hidden=\"true\"\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t'pointer-events-none absolute block rounded-full',\n\t\t\t\t\t\tscrollbarThumbClassName ?? 'bg-foreground/45',\n\t\t\t\t\t\torientation === 'horizontal' ? 'h-full top-0' : 'w-full left-0',\n\t\t\t\t\t)}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t},\n);\nScrollBar.displayName = 'ScrollBar';\n",
      "type": "registry:component"
    }
  ]
}