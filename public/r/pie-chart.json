{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pie-chart",
  "type": "registry:component",
  "title": "Pie Chart",
  "description": "Interactive pie chart with tooltips, legend, and data table helpers",
  "dependencies": [
    "clsx",
    "d3-shape",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/pie-chart.tsx",
      "content": "'use client';\n\nimport type { PieArcDatum } from 'd3-shape';\nimport { arc, pie } from 'd3-shape';\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\n\ntype ChartDatum = Record<string, unknown>;\n\nconst DEFAULT_HEIGHT = 280;\nconst DEFAULT_COLORS = [\n\t'var(--color-chart-1)',\n\t'var(--color-chart-2)',\n\t'var(--color-chart-3)',\n\t'var(--color-chart-4)',\n\t'var(--color-chart-5)',\n] as const;\n\nexport type PieChartSlice<TData extends ChartDatum = ChartDatum> = {\n\tid: string;\n\tdatum: TData;\n\tvalue: number;\n\tlabel: string;\n\tcolor: string;\n\tindex: number;\n\tpercentage: number;\n};\n\ninterface PieChartContextValue<TData extends ChartDatum> {\n\tslices: PieChartSlice<TData>[];\n\ttotal: number;\n\tformatLabel: (slice: PieChartSlice<TData>) => React.ReactNode;\n\tformatValue: (slice: PieChartSlice<TData>) => React.ReactNode;\n\tvalueLabel: string;\n\tactiveSliceId: string | null;\n\tsetActiveSliceId: (id: string | null) => void;\n}\n\nconst PieChartContext =\n\tReact.createContext<PieChartContextValue<ChartDatum> | null>(null);\n\nconst PIE_CHART_ACTIONS_MARKER = Symbol('PieChartActions');\nconst PIE_CHART_TITLE_MARKER = Symbol('PieChartTitle');\nconst PIE_CHART_DESCRIPTION_MARKER = Symbol('PieChartDescription');\n\nexport function usePieChartContext<TData extends ChartDatum = ChartDatum>() {\n\tconst context = React.useContext(\n\t\tPieChartContext,\n\t) as PieChartContextValue<TData> | null;\n\n\tif (!context) {\n\t\tthrow new Error(\n\t\t\t'usePieChartContext must be used within a <PieChart> component.',\n\t\t);\n\t}\n\n\treturn context;\n}\n\nfunction getNumericValue(input: unknown): number {\n\tif (typeof input === 'number' && Number.isFinite(input)) {\n\t\treturn input;\n\t}\n\tif (typeof input === 'string') {\n\t\tconst parsed = Number.parseFloat(input);\n\t\tif (Number.isFinite(parsed)) {\n\t\t\treturn parsed;\n\t\t}\n\t}\n\treturn 0;\n}\n\nfunction resolveRadius(\n\tvalue: number | string | undefined,\n\tbase: number,\n\tdefaultValue: number,\n): number {\n\tif (typeof value === 'number' && Number.isFinite(value)) {\n\t\treturn Math.max(0, value);\n\t}\n\tif (typeof value === 'string') {\n\t\tconst trimmed = value.trim();\n\t\tif (trimmed.endsWith('%')) {\n\t\t\tconst percentage = Number.parseFloat(trimmed.slice(0, -1));\n\t\t\tif (Number.isFinite(percentage)) {\n\t\t\t\treturn Math.max(0, (percentage / 100) * base);\n\t\t\t}\n\t\t}\n\t\tconst numeric = Number.parseFloat(trimmed);\n\t\tif (Number.isFinite(numeric)) {\n\t\t\treturn Math.max(0, numeric);\n\t\t}\n\t}\n\treturn defaultValue;\n}\n\nfunction resolveSliceColor(palette: readonly string[], index: number): string {\n\tif (palette.length === 0) {\n\t\tconst fallbackIndex =\n\t\t\tDEFAULT_COLORS.length > 0 ? index % DEFAULT_COLORS.length : 0;\n\t\tconst color = DEFAULT_COLORS[fallbackIndex];\n\t\tif (color == null) {\n\t\t\tthrow new Error(\n\t\t\t\t`No fallback color found for fallbackIndex=${fallbackIndex}`,\n\t\t\t);\n\t\t}\n\t\treturn color;\n\t}\n\tconst paletteIndex = palette.length > 0 ? index % palette.length : 0;\n\tconst fallbackIndex =\n\t\tDEFAULT_COLORS.length > 0 ? index % DEFAULT_COLORS.length : 0;\n\tconst color = palette[paletteIndex] ?? DEFAULT_COLORS[fallbackIndex];\n\tif (color == null) {\n\t\tthrow new Error(\n\t\t\t`No color found for paletteIndex=${paletteIndex}, fallbackIndex=${fallbackIndex}`,\n\t\t);\n\t}\n\treturn color;\n}\n\nfunction toKeyLabel(key: string): string {\n\tconst words = key\n\t\t.replace(/([a-z0-9])([A-Z])/g, '$1 $2')\n\t\t.replace(/[_-]+/g, ' ')\n\t\t.split(' ')\n\t\t.map((part) => part.trim())\n\t\t.filter(Boolean)\n\t\t.map((part) => part.slice(0, 1).toUpperCase() + part.slice(1));\n\treturn words.length ? words.join(' ') : key;\n}\n\nexport interface PieChartProps<TData extends ChartDatum = ChartDatum>\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tdata: TData[];\n\tvalueKey: Extract<keyof TData, string>;\n\tnameKey?: Extract<keyof TData, string>;\n\tcolors?: readonly string[];\n\tsortSlices?: boolean | ((a: TData, b: TData) => number);\n\tvalueFormatter?: (\n\t\tslice: PieChartSlice<TData>,\n\t\tmeta: { total: number; percentage: number },\n\t) => React.ReactNode;\n\tlabelFormatter?: (slice: PieChartSlice<TData>) => React.ReactNode;\n\tchildren?: React.ReactNode;\n}\n\nfunction PieChartRootInner<TData extends ChartDatum>(\n\t{\n\t\tdata,\n\t\tvalueKey,\n\t\tnameKey,\n\t\tcolors = DEFAULT_COLORS,\n\t\tsortSlices = false,\n\t\tvalueFormatter,\n\t\tlabelFormatter,\n\t\tclassName,\n\t\tchildren,\n\t\t...rest\n\t}: PieChartProps<TData>,\n\tref: React.ForwardedRef<HTMLDivElement>,\n) {\n\tconst [activeSliceId, setActiveSliceId] = React.useState<string | null>(null);\n\n\tconst valueLabel = React.useMemo(() => toKeyLabel(valueKey), [valueKey]);\n\n\tconst { slices, total } = React.useMemo(() => {\n\t\tconst palette = colors.length ? colors : DEFAULT_COLORS;\n\n\t\tconst mapped = data.reduce<PieChartSlice<TData>[]>((acc, datum, index) => {\n\t\t\tconst numericValue = Math.max(0, getNumericValue(datum[valueKey]));\n\t\t\tif (numericValue <= 0) return acc;\n\n\t\t\tconst rawLabel =\n\t\t\t\tnameKey && datum[nameKey] != null\n\t\t\t\t\t? String(datum[nameKey])\n\t\t\t\t\t: `Slice ${index + 1}`;\n\n\t\t\tconst color = resolveSliceColor(palette, index);\n\n\t\t\tacc.push({\n\t\t\t\tid: `${rawLabel}-${index}`,\n\t\t\t\tdatum,\n\t\t\t\tvalue: numericValue,\n\t\t\t\tlabel: rawLabel,\n\t\t\t\tcolor,\n\t\t\t\tindex,\n\t\t\t\tpercentage: 0,\n\t\t\t});\n\n\t\t\treturn acc;\n\t\t}, []);\n\n\t\tconst sorted = (() => {\n\t\t\tif (typeof sortSlices === 'function') {\n\t\t\t\treturn [...mapped].sort((a, b) => sortSlices(a.datum, b.datum));\n\t\t\t}\n\t\t\tif (sortSlices) {\n\t\t\t\treturn [...mapped].sort((a, b) => b.value - a.value);\n\t\t\t}\n\t\t\treturn mapped;\n\t\t})();\n\n\t\tconst totalValue = sorted.reduce((sum, slice) => sum + slice.value, 0);\n\n\t\tconst withPercentages = sorted.map<PieChartSlice<TData>>((slice) => ({\n\t\t\t...slice,\n\t\t\tpercentage: totalValue > 0 ? slice.value / totalValue : 0,\n\t\t}));\n\n\t\treturn {\n\t\t\tslices: withPercentages,\n\t\t\ttotal: totalValue,\n\t\t};\n\t}, [colors, data, nameKey, sortSlices, valueKey]);\n\n\tReact.useEffect(() => {\n\t\tif (!activeSliceId) return;\n\t\tif (!slices.some((slice) => slice.id === activeSliceId)) {\n\t\t\tsetActiveSliceId(null);\n\t\t}\n\t}, [activeSliceId, slices]);\n\n\tconst formatLabel = React.useCallback(\n\t\t(slice: PieChartSlice<TData>) => {\n\t\t\tif (labelFormatter) return labelFormatter(slice);\n\t\t\treturn slice.label;\n\t\t},\n\t\t[labelFormatter],\n\t);\n\n\tconst formatValue = React.useCallback(\n\t\t(slice: PieChartSlice<TData>) => {\n\t\t\tif (valueFormatter) {\n\t\t\t\treturn valueFormatter(slice, {\n\t\t\t\t\ttotal,\n\t\t\t\t\tpercentage: slice.percentage,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn slice.value.toLocaleString();\n\t\t},\n\t\t[valueFormatter, total],\n\t);\n\n\tconst contextValue = React.useMemo<PieChartContextValue<TData>>(\n\t\t() => ({\n\t\t\tslices,\n\t\t\ttotal,\n\t\t\tformatLabel,\n\t\t\tformatValue,\n\t\t\tvalueLabel,\n\t\t\tactiveSliceId,\n\t\t\tsetActiveSliceId,\n\t\t}),\n\t\t[activeSliceId, formatLabel, formatValue, slices, total, valueLabel],\n\t);\n\n\treturn (\n\t\t<PieChartContext.Provider\n\t\t\tvalue={contextValue as PieChartContextValue<ChartDatum>}\n\t\t>\n\t\t\t<div\n\t\t\t\tref={ref}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'relative flex flex-col rounded-lg border border-border bg-card shadow-md card-highlight',\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t\t{...rest}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t</div>\n\t\t</PieChartContext.Provider>\n\t);\n}\n\ntype PieChartComponent = <TData extends ChartDatum = ChartDatum>(\n\tprops: PieChartProps<TData> & { ref?: React.Ref<HTMLDivElement> },\n) => React.ReactElement | null;\n\nconst PieChartRoot = React.forwardRef(PieChartRootInner) as PieChartComponent;\n\nexport interface PieChartTitleProps {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n\tas?: React.ElementType;\n}\n\ntype PieChartTitleComponent = React.FC<PieChartTitleProps> & {\n\t[PIE_CHART_TITLE_MARKER]: true;\n};\n\nexport const PieChartTitle = (({\n\tchildren,\n\tclassName = '',\n\tas: Component = 'h3',\n\t...props\n}: PieChartTitleProps) => {\n\treturn React.createElement(\n\t\tComponent,\n\t\t{\n\t\t\tclassName: cn(\n\t\t\t\t'text-base font-medium leading-none text-foreground',\n\t\t\t\tclassName,\n\t\t\t),\n\t\t\t...props,\n\t\t},\n\t\tchildren,\n\t);\n}) as PieChartTitleComponent;\nPieChartTitle.displayName = 'PieChartTitle';\nPieChartTitle[PIE_CHART_TITLE_MARKER] = true;\n\nexport interface PieChartDescriptionProps\n\textends React.HTMLAttributes<HTMLParagraphElement> {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n}\n\ntype PieChartDescriptionComponent = React.FC<PieChartDescriptionProps> & {\n\t[PIE_CHART_DESCRIPTION_MARKER]: true;\n};\n\nexport const PieChartDescription = (({\n\tchildren,\n\tclassName = '',\n\t...props\n}: PieChartDescriptionProps) => {\n\treturn (\n\t\t<p\n\t\t\tclassName={cn(\n\t\t\t\t'text-sm leading-snug text-foreground/45 text-balance',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t</p>\n\t);\n}) as PieChartDescriptionComponent;\nPieChartDescription.displayName = 'PieChartDescription';\nPieChartDescription[PIE_CHART_DESCRIPTION_MARKER] = true;\n\nexport interface PieChartActionsProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n}\n\ntype PieChartActionsComponent = React.FC<PieChartActionsProps> & {\n\t[PIE_CHART_ACTIONS_MARKER]: true;\n};\n\nexport const PieChartActions = (({ children, className = '', ...props }) => {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t'flex items-center gap-2 self-start sm:self-auto',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t</div>\n\t);\n}) as PieChartActionsComponent;\nPieChartActions.displayName = 'PieChartActions';\nPieChartActions[PIE_CHART_ACTIONS_MARKER] = true;\n\nfunction hasPieChartMarker(\n\ttarget: unknown,\n\tmarker: symbol,\n): target is { [key: symbol]: unknown } {\n\tif (!target) return false;\n\tif (\n\t\t(typeof target === 'function' || typeof target === 'object') &&\n\t\ttarget !== null &&\n\t\tReflect.get(target, marker)\n\t) {\n\t\treturn true;\n\t}\n\tif (\n\t\ttypeof target === 'object' &&\n\t\ttarget !== null &&\n\t\t'type' in target &&\n\t\t(target as { type?: unknown }).type\n\t) {\n\t\treturn hasPieChartMarker((target as { type?: unknown }).type, marker);\n\t}\n\treturn false;\n}\n\nfunction cloneElementWithClassName<TProps extends { className?: string }>(\n\telement: React.ReactElement<TProps>,\n\tadditionalClassName?: string,\n) {\n\tif (!additionalClassName) {\n\t\treturn element;\n\t}\n\tconst mergedClassName = cn(element.props.className, additionalClassName);\n\treturn React.cloneElement(element, {\n\t\tclassName: mergedClassName,\n\t} as Partial<TProps> & React.Attributes);\n}\n\nfunction isPieChartActionsElement(\n\tchild: React.ReactNode,\n): child is React.ReactElement {\n\tif (!React.isValidElement(child)) return false;\n\tconst { type } = child;\n\tif (type === PieChartActions) return true;\n\tif (hasPieChartMarker(type, PIE_CHART_ACTIONS_MARKER)) return true;\n\tconst displayName =\n\t\ttypeof type === 'function' || (typeof type === 'object' && type !== null)\n\t\t\t? (type as { displayName?: string }).displayName\n\t\t\t: undefined;\n\treturn displayName === PieChartActions.displayName;\n}\n\nfunction isPieChartTitleElement(\n\tchild: React.ReactNode,\n): child is React.ReactElement<PieChartTitleProps> {\n\tif (!React.isValidElement(child)) return false;\n\tconst { type } = child;\n\tif (type === PieChartTitle) return true;\n\tif (hasPieChartMarker(type, PIE_CHART_TITLE_MARKER)) return true;\n\tconst displayName =\n\t\ttypeof type === 'function' || (typeof type === 'object' && type !== null)\n\t\t\t? (type as { displayName?: string }).displayName\n\t\t\t: undefined;\n\treturn displayName === PieChartTitle.displayName;\n}\n\nfunction isPieChartDescriptionElement(\n\tchild: React.ReactNode,\n): child is React.ReactElement<PieChartDescriptionProps> {\n\tif (!React.isValidElement(child)) return false;\n\tconst { type } = child;\n\tif (type === PieChartDescription) return true;\n\tif (hasPieChartMarker(type, PIE_CHART_DESCRIPTION_MARKER)) return true;\n\tconst displayName =\n\t\ttypeof type === 'function' || (typeof type === 'object' && type !== null)\n\t\t\t? (type as { displayName?: string }).displayName\n\t\t\t: undefined;\n\treturn displayName === PieChartDescription.displayName;\n}\n\nexport interface PieChartHeaderProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tcontentClassName?: string;\n\ttitleClassName?: string;\n\tdescriptionClassName?: string;\n\tactionsClassName?: string;\n}\n\nexport const PieChartHeader = React.forwardRef<\n\tHTMLDivElement,\n\tPieChartHeaderProps\n>(\n\t(\n\t\t{\n\t\t\tclassName = '',\n\t\t\tchildren,\n\t\t\tcontentClassName,\n\t\t\ttitleClassName,\n\t\t\tdescriptionClassName,\n\t\t\tactionsClassName,\n\t\t\t...props\n\t\t},\n\t\tref,\n\t) => {\n\t\tconst childrenArray = React.Children.toArray(children);\n\t\tconst mainChildren: React.ReactNode[] = [];\n\t\tconst actionChildren: React.ReactNode[] = [];\n\n\t\tchildrenArray.forEach((child) => {\n\t\t\tif (isPieChartActionsElement(child)) {\n\t\t\t\tactionChildren.push(child);\n\t\t\t} else if (child !== null) {\n\t\t\t\tmainChildren.push(child);\n\t\t\t}\n\t\t});\n\n\t\tconst enhancedMainChildren = mainChildren.map((child) => {\n\t\t\tif (isPieChartTitleElement(child)) {\n\t\t\t\treturn cloneElementWithClassName(\n\t\t\t\t\tchild as React.ReactElement<{ className?: string }>,\n\t\t\t\t\ttitleClassName,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (isPieChartDescriptionElement(child)) {\n\t\t\t\treturn cloneElementWithClassName(\n\t\t\t\t\tchild as React.ReactElement<{ className?: string }>,\n\t\t\t\t\tdescriptionClassName,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn child;\n\t\t});\n\n\t\tconst enhancedActionChildren = actionChildren.map((child) => {\n\t\t\tif (isPieChartActionsElement(child)) {\n\t\t\t\treturn cloneElementWithClassName(\n\t\t\t\t\tchild as React.ReactElement<{ className?: string }>,\n\t\t\t\t\tactionsClassName,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn child;\n\t\t});\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={ref}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'flex flex-col gap-3 px-4 pt-4 sm:flex-row sm:items-start sm:justify-between sm:gap-4',\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{enhancedMainChildren.length ? (\n\t\t\t\t\t<div className={cn('space-y-1 sm:flex-1', contentClassName)}>\n\t\t\t\t\t\t{enhancedMainChildren}\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t\t{enhancedActionChildren.length ? enhancedActionChildren : null}\n\t\t\t</div>\n\t\t);\n\t},\n);\nPieChartHeader.displayName = 'PieChartHeader';\n\nexport interface PieChartTooltipInfo<TData extends ChartDatum = ChartDatum> {\n\tslice: PieChartSlice<TData>;\n\tvalue: number;\n\tpercentage: number;\n}\n\nexport interface PieChartGraphProps<TData extends ChartDatum = ChartDatum>\n\textends React.HTMLAttributes<HTMLDivElement> {\n\theight?: number | string;\n\tinnerRadius?: number | string;\n\touterRadius?: number | string;\n\tpadAngle?: number;\n\tcornerRadius?: number;\n\tstartAngle?: number;\n\tendAngle?: number;\n\tshowTooltip?: boolean;\n\ttooltipRender?: (info: PieChartTooltipInfo<TData>) => React.ReactNode;\n\tloading?: boolean;\n\tloadingState?: React.ReactNode;\n\temptyState?: React.ReactNode;\n\terror?: React.ReactNode;\n\tariaLabel?: string;\n\tchildren?: React.ReactNode;\n}\n\nfunction PieChartState({\n\tlabel,\n\tdescription,\n}: {\n\tlabel: string;\n\tdescription?: React.ReactNode;\n}) {\n\treturn (\n\t\t<div className=\"flex h-full w-full items-center justify-center rounded-md border border-dashed border-border/60 bg-card-muted/30 px-4 py-10 text-center\">\n\t\t\t<div className=\"space-y-2\">\n\t\t\t\t<p className=\"text-sm leading-none font-medium text-foreground\">\n\t\t\t\t\t{label}\n\t\t\t\t</p>\n\t\t\t\t{description ? (\n\t\t\t\t\t<p className=\"text-sm leading-snug text-foreground/45\">\n\t\t\t\t\t\t{description}\n\t\t\t\t\t</p>\n\t\t\t\t) : null}\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nconst PieChartGraphBase = React.forwardRef<\n\tHTMLDivElement,\n\tPieChartGraphProps<ChartDatum>\n>(function PieChartGraphInner(\n\t{\n\t\theight,\n\t\tinnerRadius,\n\t\touterRadius,\n\t\tpadAngle = 0,\n\t\tcornerRadius = 0,\n\t\tstartAngle,\n\t\tendAngle,\n\t\tshowTooltip = true,\n\t\ttooltipRender,\n\t\tloading = false,\n\t\tloadingState,\n\t\temptyState,\n\t\terror,\n\t\tariaLabel,\n\t\tchildren,\n\t\tclassName,\n\t\tstyle,\n\t\t...rest\n\t}: PieChartGraphProps<ChartDatum>,\n\tref,\n) {\n\tconst {\n\t\tslices,\n\t\tformatLabel,\n\t\tformatValue,\n\t\tvalueLabel,\n\t\tactiveSliceId,\n\t\tsetActiveSliceId,\n\t} = usePieChartContext();\n\n\tconst chartAreaRef = React.useRef<HTMLDivElement | null>(null);\n\tconst svgRef = React.useRef<SVGSVGElement | null>(null);\n\tconst pathElementsRef = React.useRef<Map<string, SVGPathElement>>(new Map());\n\tconst registerPathElement = React.useCallback(\n\t\t(id: string, element: SVGPathElement | null) => {\n\t\t\tconst map = pathElementsRef.current;\n\t\t\tif (element) {\n\t\t\t\tmap.set(id, element);\n\t\t\t} else {\n\t\t\t\tmap.delete(id);\n\t\t\t}\n\t\t},\n\t\t[],\n\t);\n\tconst setOuterContainerRef = React.useCallback(\n\t\t(node: HTMLDivElement | null) => {\n\t\t\tif (typeof ref === 'function') {\n\t\t\t\tref(node);\n\t\t\t} else if (ref) {\n\t\t\t\t(ref as React.RefObject<HTMLDivElement | null>).current = node;\n\t\t\t}\n\t\t},\n\t\t[ref],\n\t);\n\n\tconst resolvedHeight =\n\t\ttypeof height === 'number'\n\t\t\t? `${height}px`\n\t\t\t: (height ?? `${DEFAULT_HEIGHT}px`);\n\n\tconst svgTitleId = React.useId();\n\tconst trimmedAriaLabel = ariaLabel?.trim();\n\tconst svgTitle =\n\t\ttrimmedAriaLabel && trimmedAriaLabel.length > 0\n\t\t\t? trimmedAriaLabel\n\t\t\t: 'Pie chart visualization';\n\n\tconst viewBoxSize = 320;\n\tconst maxRadius = viewBoxSize / 2 - 8;\n\n\tconst resolvedOuterRadius = Math.min(\n\t\tresolveRadius(outerRadius, maxRadius, maxRadius),\n\t\tmaxRadius,\n\t);\n\tconst resolvedInnerRadius = Math.min(\n\t\tresolveRadius(innerRadius, maxRadius, 0),\n\t\tresolvedOuterRadius,\n\t);\n\n\tconst sanitizedPadAngle =\n\t\ttypeof padAngle === 'number' && Number.isFinite(padAngle)\n\t\t\t? Math.max(padAngle, 0)\n\t\t\t: 0;\n\tconst padAngleRad = (sanitizedPadAngle * Math.PI) / 180;\n\tconst sanitizedCornerRadius =\n\t\ttypeof cornerRadius === 'number' && Number.isFinite(cornerRadius)\n\t\t\t? Math.max(cornerRadius, 0)\n\t\t\t: 0;\n\tconst startAngleRad =\n\t\tstartAngle !== undefined ? (startAngle * Math.PI) / 180 : undefined;\n\tconst endAngleRad =\n\t\tendAngle !== undefined ? (endAngle * Math.PI) / 180 : undefined;\n\n\tconst arcGenerator = React.useMemo(\n\t\t() =>\n\t\t\tarc<PieArcDatum<PieChartSlice>>()\n\t\t\t\t.innerRadius(resolvedInnerRadius)\n\t\t\t\t.outerRadius(resolvedOuterRadius)\n\t\t\t\t.cornerRadius(sanitizedCornerRadius),\n\t\t[resolvedInnerRadius, resolvedOuterRadius, sanitizedCornerRadius],\n\t);\n\n\tconst arcs = React.useMemo(() => {\n\t\tconst generator = pie<PieChartSlice>()\n\t\t\t.value((slice: PieChartSlice) => slice.value)\n\t\t\t.sort(null)\n\t\t\t.padAngle(padAngleRad);\n\n\t\tif (startAngleRad !== undefined) generator.startAngle(startAngleRad);\n\t\tif (endAngleRad !== undefined) generator.endAngle(endAngleRad);\n\n\t\treturn generator(slices);\n\t}, [endAngleRad, padAngleRad, slices, startAngleRad]);\n\n\tconst defaultTooltipRender = React.useCallback(\n\t\t(info: PieChartTooltipInfo) => (\n\t\t\t<div className=\"space-y-1\">\n\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t<span\n\t\t\t\t\t\tclassName=\"inline-flex h-2.5 w-1 shrink-0 rounded-[1px]\"\n\t\t\t\t\t\tstyle={{ backgroundColor: info.slice.color }}\n\t\t\t\t\t/>\n\t\t\t\t\t<span className=\"text-xs font-medium text-foreground\">\n\t\t\t\t\t\t{formatLabel(info.slice)}\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t<span className=\"text-xs text-foreground/70\">\n\t\t\t\t\t\t{formatValue(info.slice)} {valueLabel}\n\t\t\t\t\t</span>\n\t\t\t\t\t<span className=\"text-xs text-foreground/45\">\n\t\t\t\t\t\t{(info.percentage * 100).toFixed(1)}%\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t),\n\t\t[formatLabel, formatValue, valueLabel],\n\t);\n\n\tconst tooltipRenderer = tooltipRender ?? defaultTooltipRender;\n\n\tconst tooltipRef = React.useRef<HTMLDivElement | null>(null);\n\tconst [tooltipDimensions, setTooltipDimensions] = React.useState<{\n\t\twidth: number;\n\t\theight: number;\n\t}>({ width: 0, height: 0 });\n\tconst [tooltip, setTooltip] = React.useState<{\n\t\tinfo: PieChartTooltipInfo;\n\t\tsliceId: string;\n\t\tx: number;\n\t\ty: number;\n\t\thorizontal: 'left' | 'right';\n\t\tvertical: 'top' | 'bottom';\n\t\tvisible: boolean;\n\t\tentering: boolean;\n\t} | null>(null);\n\n\tconst hideTooltipTimeoutRef = React.useRef<number | null>(null);\n\n\tconst cancelScheduledTooltipHide = React.useCallback(() => {\n\t\tif (hideTooltipTimeoutRef.current !== null) {\n\t\t\twindow.clearTimeout(hideTooltipTimeoutRef.current);\n\t\t\thideTooltipTimeoutRef.current = null;\n\t\t}\n\t}, []);\n\n\tconst clearTooltip = React.useCallback(() => {\n\t\tcancelScheduledTooltipHide();\n\t\tsetTooltip((previous) =>\n\t\t\tprevious ? { ...previous, visible: false, entering: false } : null,\n\t\t);\n\t\tsetActiveSliceId(null);\n\t}, [cancelScheduledTooltipHide, setActiveSliceId]);\n\n\tconst scheduleTooltipHide = React.useCallback(\n\t\t(delay = 140) => {\n\t\t\tcancelScheduledTooltipHide();\n\t\t\thideTooltipTimeoutRef.current = window.setTimeout(() => {\n\t\t\t\tclearTooltip();\n\t\t\t}, delay);\n\t\t},\n\t\t[cancelScheduledTooltipHide, clearTooltip],\n\t);\n\n\tconst handleSvgPointerLeave = React.useCallback(\n\t\t(event: React.PointerEvent<SVGSVGElement>) => {\n\t\t\tconst delay =\n\t\t\t\tevent.pointerType === 'touch' || event.pointerType === 'pen'\n\t\t\t\t\t? 320\n\t\t\t\t\t: 140;\n\t\t\tscheduleTooltipHide(delay);\n\t\t},\n\t\t[scheduleTooltipHide],\n\t);\n\n\tconst renderTooltip =\n\t\tshowTooltip && tooltip ? tooltipRenderer(tooltip.info) : null;\n\n\tconst showChart = !loading && !error && slices.length > 0;\n\n\tReact.useEffect(() => {\n\t\tif (!showChart) {\n\t\t\tsetTooltip(null);\n\t\t}\n\t}, [showChart]);\n\n\tReact.useEffect(() => {\n\t\tif (!tooltip || tooltip.visible || tooltip.entering) return;\n\t\tconst timeoutId = window.setTimeout(() => {\n\t\t\tsetTooltip(null);\n\t\t}, 200);\n\t\treturn () => window.clearTimeout(timeoutId);\n\t}, [tooltip]);\n\n\tReact.useLayoutEffect(() => {\n\t\tif (\n\t\t\t!tooltipRef.current ||\n\t\t\t!tooltip ||\n\t\t\ttypeof ResizeObserver === 'undefined'\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tconst observer = new ResizeObserver(([entry]) => {\n\t\t\tif (!entry) return;\n\t\t\tconst { width, height } = entry.contentRect;\n\t\t\tsetTooltipDimensions({ width, height });\n\t\t});\n\t\tobserver.observe(tooltipRef.current);\n\t\treturn () => observer.disconnect();\n\t}, [tooltip]);\n\n\tReact.useLayoutEffect(() => {\n\t\tif (!tooltip || !tooltip.entering) {\n\t\t\treturn;\n\t\t}\n\t\tconst frameId = window?.requestAnimationFrame(() => {\n\t\t\tsetTooltip((previous) =>\n\t\t\t\tprevious?.entering\n\t\t\t\t\t? { ...previous, visible: true, entering: false }\n\t\t\t\t\t: previous,\n\t\t\t);\n\t\t});\n\t\treturn () => window.cancelAnimationFrame(frameId);\n\t}, [tooltip]);\n\n\tReact.useEffect(\n\t\t() => () => {\n\t\t\tcancelScheduledTooltipHide();\n\t\t},\n\t\t[cancelScheduledTooltipHide],\n\t);\n\n\tconst calculateTooltipPosition = React.useCallback(\n\t\t(arcDatum: PieArcDatum<PieChartSlice>, element?: SVGPathElement | null) => {\n\t\t\tif (!chartAreaRef.current) return null;\n\n\t\t\tconst containerRect = chartAreaRef.current.getBoundingClientRect();\n\n\t\t\tconst [centroidX, centroidY] = arcGenerator.centroid(arcDatum);\n\t\t\tconst center = viewBoxSize / 2;\n\n\t\t\tconst directionX = centroidX;\n\t\t\tconst directionY = centroidY;\n\t\t\tconst directionLength = Math.hypot(directionX, directionY) || 1;\n\t\t\tconst angle = Math.atan2(directionY, directionX);\n\n\t\t\tconst tooltipPadding = 12;\n\t\t\tconst estimatedWidth = tooltipDimensions.width || 220;\n\t\t\tconst estimatedHeight = tooltipDimensions.height || 96;\n\n\t\t\tlet anchorPointX: number | null = null;\n\t\t\tlet anchorPointY: number | null = null;\n\n\t\t\tif (element) {\n\t\t\t\tconst elementRect = element.getBoundingClientRect();\n\t\t\t\tconst localLeft = elementRect.left - containerRect.left;\n\t\t\t\tconst localTop = elementRect.top - containerRect.top;\n\t\t\t\tanchorPointX = localLeft + elementRect.width / 2;\n\t\t\t\tanchorPointY = localTop + elementRect.height / 2;\n\t\t\t} else if (svgRef.current) {\n\t\t\t\tconst svgRect = svgRef.current.getBoundingClientRect();\n\t\t\t\tconst scale = Math.min(\n\t\t\t\t\tsvgRect.width / viewBoxSize,\n\t\t\t\t\tsvgRect.height / viewBoxSize,\n\t\t\t\t);\n\t\t\t\tif (!Number.isFinite(scale) || scale <= 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst offsetX =\n\t\t\t\t\tsvgRect.left -\n\t\t\t\t\tcontainerRect.left +\n\t\t\t\t\t(svgRect.width - viewBoxSize * scale) / 2;\n\t\t\t\tconst offsetY =\n\t\t\t\t\tsvgRect.top -\n\t\t\t\t\tcontainerRect.top +\n\t\t\t\t\t(svgRect.height - viewBoxSize * scale) / 2;\n\n\t\t\t\tconst preferredRadius =\n\t\t\t\t\tresolvedInnerRadius +\n\t\t\t\t\t(resolvedOuterRadius - resolvedInnerRadius) * 0.6;\n\t\t\t\tconst safeOuterRadius = Math.max(0, resolvedOuterRadius - 12);\n\t\t\t\tconst safeInnerRadius = Math.min(\n\t\t\t\t\tsafeOuterRadius,\n\t\t\t\t\tresolvedInnerRadius + 12,\n\t\t\t\t);\n\t\t\t\tconst targetRadius = Math.min(\n\t\t\t\t\tsafeOuterRadius,\n\t\t\t\t\tMath.max(safeInnerRadius, preferredRadius),\n\t\t\t\t);\n\n\t\t\t\tconst offsetDistance = 18;\n\t\t\t\tconst targetX =\n\t\t\t\t\t(directionX / directionLength) * targetRadius +\n\t\t\t\t\tMath.cos(angle) * offsetDistance;\n\t\t\t\tconst targetY =\n\t\t\t\t\t(directionY / directionLength) * targetRadius +\n\t\t\t\t\tMath.sin(angle) * offsetDistance;\n\n\t\t\t\tanchorPointX = offsetX + (targetX + center) * scale;\n\t\t\t\tanchorPointY = offsetY + (targetY + center) * scale;\n\t\t\t}\n\n\t\t\tif (anchorPointX === null || anchorPointY === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst anchorOffset = 0;\n\t\t\tconst offsetX = Math.cos(angle) * anchorOffset;\n\t\t\tconst offsetY = Math.sin(angle) * anchorOffset;\n\n\t\t\tconst centeredX = anchorPointX + offsetX;\n\t\t\tconst centeredY = anchorPointY + offsetY;\n\n\t\t\tconst minX = tooltipPadding;\n\t\t\tconst maxX = containerRect.width - estimatedWidth - tooltipPadding;\n\t\t\tconst minY = tooltipPadding;\n\t\t\tconst maxY = containerRect.height - estimatedHeight - tooltipPadding;\n\n\t\t\tlet x = centeredX - estimatedWidth / 2;\n\t\t\tlet y = centeredY - estimatedHeight / 2;\n\n\t\t\tx = Math.min(Math.max(x, minX), maxX);\n\t\t\ty = Math.min(Math.max(y, minY), maxY);\n\n\t\t\tlet horizontal: 'left' | 'right' =\n\t\t\t\tMath.cos(angle) >= 0 ? 'right' : 'left';\n\t\t\tlet vertical: 'top' | 'bottom' = Math.sin(angle) >= 0 ? 'bottom' : 'top';\n\n\t\t\tif (x <= minX + 1) {\n\t\t\t\thorizontal = 'right';\n\t\t\t} else if (x >= maxX - 1) {\n\t\t\t\thorizontal = 'left';\n\t\t\t}\n\n\t\t\tif (y <= minY + 1) {\n\t\t\t\tvertical = 'bottom';\n\t\t\t} else if (y >= maxY - 1) {\n\t\t\t\tvertical = 'top';\n\t\t\t}\n\n\t\t\treturn { x, y, horizontal, vertical };\n\t\t},\n\t\t[arcGenerator, resolvedInnerRadius, resolvedOuterRadius, tooltipDimensions],\n\t);\n\n\tconst updateTooltipForSlice = React.useCallback(\n\t\t(arcDatum: PieArcDatum<PieChartSlice>, element?: SVGPathElement | null) => {\n\t\t\tcancelScheduledTooltipHide();\n\t\t\tsetActiveSliceId(arcDatum.data.id);\n\n\t\t\tif (!showTooltip) return;\n\n\t\t\tconst targetElement =\n\t\t\t\telement ?? pathElementsRef.current.get(arcDatum.data.id) ?? null;\n\n\t\t\tconst position = calculateTooltipPosition(arcDatum, targetElement);\n\t\t\tif (!position) return;\n\n\t\t\tsetTooltip((previous) => {\n\t\t\t\tconst shouldAnimateIn = !previous || !previous.visible;\n\n\t\t\t\tconst next = {\n\t\t\t\t\tinfo: {\n\t\t\t\t\t\tslice: arcDatum.data,\n\t\t\t\t\t\tvalue: arcDatum.data.value,\n\t\t\t\t\t\tpercentage: arcDatum.data.percentage,\n\t\t\t\t\t},\n\t\t\t\t\tsliceId: arcDatum.data.id,\n\t\t\t\t\tx: position.x,\n\t\t\t\t\ty: position.y,\n\t\t\t\t\thorizontal: position.horizontal,\n\t\t\t\t\tvertical: position.vertical,\n\t\t\t\t\tvisible: !shouldAnimateIn,\n\t\t\t\t\tentering: shouldAnimateIn,\n\t\t\t\t};\n\n\t\t\t\tif (\n\t\t\t\t\tprevious &&\n\t\t\t\t\tprevious.sliceId === arcDatum.data.id &&\n\t\t\t\t\tMath.abs(previous.x - next.x) < 0.5 &&\n\t\t\t\t\tMath.abs(previous.y - next.y) < 0.5 &&\n\t\t\t\t\tprevious.horizontal === next.horizontal &&\n\t\t\t\t\tprevious.vertical === next.vertical\n\t\t\t\t) {\n\t\t\t\t\tif (shouldAnimateIn) {\n\t\t\t\t\t\treturn next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!previous.visible) {\n\t\t\t\t\t\treturn { ...previous, visible: true, entering: false };\n\t\t\t\t\t}\n\t\t\t\t\treturn previous;\n\t\t\t\t}\n\n\t\t\t\treturn next;\n\t\t\t});\n\t\t},\n\t\t[\n\t\t\tcancelScheduledTooltipHide,\n\t\t\tcalculateTooltipPosition,\n\t\t\tsetActiveSliceId,\n\t\t\tshowTooltip,\n\t\t],\n\t);\n\n\tReact.useEffect(() => {\n\t\tif (!tooltip || !tooltip.visible) return;\n\n\t\tconst arcDatum = arcs.find(\n\t\t\t(candidate) => candidate.data.id === tooltip.sliceId,\n\t\t);\n\t\tif (!arcDatum) return;\n\n\t\tconst element = pathElementsRef.current.get(arcDatum.data.id) ?? null;\n\n\t\tconst position = calculateTooltipPosition(arcDatum, element);\n\t\tif (!position) return;\n\n\t\tif (\n\t\t\tMath.abs(tooltip.x - position.x) < 0.5 &&\n\t\t\tMath.abs(tooltip.y - position.y) < 0.5 &&\n\t\t\ttooltip.horizontal === position.horizontal &&\n\t\t\ttooltip.vertical === position.vertical\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tsetTooltip((previous) =>\n\t\t\tprevious\n\t\t\t\t? {\n\t\t\t\t\t\t...previous,\n\t\t\t\t\t\tx: position.x,\n\t\t\t\t\t\ty: position.y,\n\t\t\t\t\t\thorizontal: position.horizontal,\n\t\t\t\t\t\tvertical: position.vertical,\n\t\t\t\t\t}\n\t\t\t\t: previous,\n\t\t);\n\t}, [arcs, calculateTooltipPosition, tooltip]);\n\n\tlet body: React.ReactNode = null;\n\n\tif (error) {\n\t\tbody =\n\t\t\ttypeof error === 'string' ? (\n\t\t\t\t<PieChartState\n\t\t\t\t\tlabel=\"There was a problem rendering the chart.\"\n\t\t\t\t\tdescription={error}\n\t\t\t\t/>\n\t\t\t) : (\n\t\t\t\terror\n\t\t\t);\n\t} else if (loading) {\n\t\tbody = loadingState ?? (\n\t\t\t<PieChartState label=\"Loading chart dataâ€¦\" description={undefined} />\n\t\t);\n\t} else if (!slices.length) {\n\t\tbody = emptyState ?? (\n\t\t\t<PieChartState\n\t\t\t\tlabel=\"No data to display yet.\"\n\t\t\t\tdescription=\"Provide a dataset or adjust your filters.\"\n\t\t\t/>\n\t\t);\n\t} else {\n\t\tbody = (\n\t\t\t/* biome-ignore lint/a11y/noSvgWithoutTitle: handled via aria-label */\n\t\t\t<svg\n\t\t\t\tref={svgRef}\n\t\t\t\tclassName=\"h-full w-full\"\n\t\t\t\tviewBox={`0 0 ${viewBoxSize} ${viewBoxSize}`}\n\t\t\t\taria-label={svgTitle}\n\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\tshapeRendering=\"geometricPrecision\"\n\t\t\t\tonPointerLeave={handleSvgPointerLeave}\n\t\t\t\t{...(trimmedAriaLabel\n\t\t\t\t\t? { role: 'img', 'aria-labelledby': svgTitleId }\n\t\t\t\t\t: { role: 'img', 'aria-hidden': true })}\n\t\t\t>\n\t\t\t\t<g transform={`translate(${viewBoxSize / 2}, ${viewBoxSize / 2})`}>\n\t\t\t\t\t{arcs.map((arcDatum) => {\n\t\t\t\t\t\tconst path = arcGenerator(arcDatum);\n\t\t\t\t\t\tif (!path) return null;\n\n\t\t\t\t\t\tconst isActive = activeSliceId === arcDatum.data.id;\n\t\t\t\t\t\tconst isDimmed =\n\t\t\t\t\t\t\tBoolean(activeSliceId) && activeSliceId !== arcDatum.data.id;\n\t\t\t\t\t\tconst labelNode = formatLabel(arcDatum.data);\n\t\t\t\t\t\tconst valueNode = formatValue(arcDatum.data);\n\t\t\t\t\t\tconst labelText =\n\t\t\t\t\t\t\ttypeof labelNode === 'string'\n\t\t\t\t\t\t\t\t? labelNode\n\t\t\t\t\t\t\t\t: typeof labelNode === 'number'\n\t\t\t\t\t\t\t\t\t? labelNode.toString()\n\t\t\t\t\t\t\t\t\t: arcDatum.data.label;\n\t\t\t\t\t\tconst valueText =\n\t\t\t\t\t\t\ttypeof valueNode === 'string'\n\t\t\t\t\t\t\t\t? valueNode\n\t\t\t\t\t\t\t\t: typeof valueNode === 'number'\n\t\t\t\t\t\t\t\t\t? valueNode.toLocaleString()\n\t\t\t\t\t\t\t\t\t: arcDatum.data.value.toLocaleString();\n\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t// biome-ignore lint/a11y/useSemanticElements: A <path> cannot be replaced with <button> inside SVG, so we provide button semantics via role.\n\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\tkey={arcDatum.data.id}\n\t\t\t\t\t\t\t\tref={(node) => {\n\t\t\t\t\t\t\t\t\tregisterPathElement(arcDatum.data.id, node);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\td={path}\n\t\t\t\t\t\t\t\tfill={arcDatum.data.color}\n\t\t\t\t\t\t\t\tstroke={arcDatum.data.color}\n\t\t\t\t\t\t\t\tstrokeWidth={0.25}\n\t\t\t\t\t\t\t\ttabIndex={0}\n\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\t\t\t\taria-label={`${labelText}: ${valueText} (${(\n\t\t\t\t\t\t\t\t\tarcDatum.data.percentage * 100\n\t\t\t\t\t\t\t\t).toFixed(1)}%)`}\n\t\t\t\t\t\t\t\tclassName=\"outline-none transition-[transform,opacity] duration-600 ease-smooth\"\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\topacity: isDimmed ? 0.5 : 1,\n\t\t\t\t\t\t\t\t\tfilter: `\n                    ${isActive ? 'brightness(0.8) saturate(1.5)' : 'brightness(1) saturate(1)'}\n                  `,\n\t\t\t\t\t\t\t\t\ttransform: isActive ? 'scale(1.03)' : undefined,\n\t\t\t\t\t\t\t\t\twillChange: 'transform, opacity, filter',\n\t\t\t\t\t\t\t\t\ttransition:\n\t\t\t\t\t\t\t\t\t\t'transform 600ms var(--ease-smooth), opacity 600ms var(--ease-smooth), filter 600ms var(--ease-smooth)',\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonPointerEnter={(event) => {\n\t\t\t\t\t\t\t\t\tupdateTooltipForSlice(arcDatum, event.currentTarget);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonPointerLeave={(event) => {\n\t\t\t\t\t\t\t\t\tconst delay =\n\t\t\t\t\t\t\t\t\t\tevent.pointerType === 'touch' || event.pointerType === 'pen'\n\t\t\t\t\t\t\t\t\t\t\t? 320\n\t\t\t\t\t\t\t\t\t\t\t: 140;\n\t\t\t\t\t\t\t\t\tscheduleTooltipHide(delay);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonClick={(event) => {\n\t\t\t\t\t\t\t\t\tupdateTooltipForSlice(arcDatum, event.currentTarget);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonFocus={(event) => {\n\t\t\t\t\t\t\t\t\tupdateTooltipForSlice(arcDatum, event.currentTarget);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonBlur={(event) => {\n\t\t\t\t\t\t\t\t\tconst nextFocusTarget =\n\t\t\t\t\t\t\t\t\t\tevent.relatedTarget instanceof Node\n\t\t\t\t\t\t\t\t\t\t\t? event.relatedTarget\n\t\t\t\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tnextFocusTarget &&\n\t\t\t\t\t\t\t\t\t\tsvgRef.current?.contains(nextFocusTarget)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tclearTooltip();\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\tonKeyDown={(event) => {\n\t\t\t\t\t\t\t\t\tif (event.key === 'Enter' || event.key === ' ') {\n\t\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\t\tupdateTooltipForSlice(arcDatum, event.currentTarget);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (event.key === 'Escape') {\n\t\t\t\t\t\t\t\t\t\tclearTooltip();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t);\n\t\t\t\t\t})}\n\t\t\t\t</g>\n\t\t\t</svg>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tref={setOuterContainerRef}\n\t\t\tclassName={cn('relative w-full p-4', className)}\n\t\t\tstyle={{ ...style, height: resolvedHeight }}\n\t\t\t{...rest}\n\t\t>\n\t\t\t<div ref={chartAreaRef} className=\"relative h-full w-full\">\n\t\t\t\t{body}\n\t\t\t\t{showChart && children ? (\n\t\t\t\t\t<div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t\t{showTooltip && tooltip && renderTooltip ? (\n\t\t\t\t\t<div\n\t\t\t\t\t\tref={tooltipRef}\n\t\t\t\t\t\tdata-visible={tooltip.visible ? '' : undefined}\n\t\t\t\t\t\tclassName=\"pointer-events-none absolute left-0 top-0 z-50\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\ttransformOrigin: `${tooltip.horizontal} ${tooltip.vertical}`,\n\t\t\t\t\t\t\ttransform: `translate3d(${tooltip.x}px, ${tooltip.y}px, 0) scale(${\n\t\t\t\t\t\t\t\ttooltip.visible ? 1 : 0.95\n\t\t\t\t\t\t\t})`,\n\t\t\t\t\t\t\topacity: tooltip.visible ? 1 : 0,\n\t\t\t\t\t\t\ttransition:\n\t\t\t\t\t\t\t\t'transform 450ms var(--ease-smooth), opacity 300ms var(--ease-smooth)',\n\t\t\t\t\t\t\twillChange: 'transform, opacity',\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<div className=\"relative min-w-32 max-w-xs rounded-md border border-border bg-popover p-2 text-xs text-foreground shadow-md card-highlight\">\n\t\t\t\t\t\t\t{renderTooltip}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t</div>\n\t\t</div>\n\t);\n});\nPieChartGraphBase.displayName = 'PieChartGraph';\n\ntype PieChartGraphComponent = <TData extends ChartDatum = ChartDatum>(\n\tprops: PieChartGraphProps<TData> & { ref?: React.Ref<HTMLDivElement> },\n) => React.ReactElement | null;\n\nexport const PieChartGraph = PieChartGraphBase as PieChartGraphComponent;\n\nexport type PieChartLegendProps = React.HTMLAttributes<HTMLDivElement>;\n\nexport const PieChartLegend = React.forwardRef<\n\tHTMLDivElement,\n\tPieChartLegendProps\n>(({ className, ...props }, ref) => {\n\tconst { slices, formatLabel } = usePieChartContext();\n\n\tif (!slices.length) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t'flex flex-wrap items-center gap-3 px-4 pb-4 pt-2 text-xs text-foreground/70',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{slices.map((slice) => (\n\t\t\t\t<div key={slice.id} className=\"flex items-center gap-2\">\n\t\t\t\t\t<span\n\t\t\t\t\t\tclassName=\"inline-flex h-2.5 w-1 shrink-0 rounded-[1px]\"\n\t\t\t\t\t\tstyle={{ backgroundColor: slice.color }}\n\t\t\t\t\t/>\n\t\t\t\t\t<span className=\"text-xs font-medium text-foreground\">\n\t\t\t\t\t\t{formatLabel(slice)}\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t))}\n\t\t</div>\n\t);\n});\nPieChartLegend.displayName = 'PieChartLegend';\n\nexport interface PieChartDataTableProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n}\n\nexport const PieChartDataTable = React.forwardRef<\n\tHTMLDivElement,\n\tPieChartDataTableProps\n>(({ className = '', children, ...props }, ref) => {\n\treturn (\n\t\t<div\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t'bg-card-muted/30 space-y-2 border-t border-border/60 p-4 text-xs text-foreground/70',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t</div>\n\t);\n});\nPieChartDataTable.displayName = 'PieChartDataTable';\n\nexport interface PieChartDataTableContentProps<\n\tTData extends ChartDatum = ChartDatum,\n> {\n\tclassName?: string;\n\trowClassName?: string;\n\tlabelClassName?: string;\n\tvalueClassName?: string;\n\tpercentageClassName?: string;\n\tshowPercentages?: boolean;\n\tshowTotalRow?: boolean;\n\ttotalLabel?: React.ReactNode;\n\ttotalFormatter?: (total: number) => React.ReactNode;\n\tpercentageFormatter?: (\n\t\tpercentage: number,\n\t\tslice: PieChartSlice<TData>,\n\t) => React.ReactNode;\n}\n\nexport function PieChartDataTableContent<\n\tTData extends ChartDatum = ChartDatum,\n>({\n\tclassName = '',\n\trowClassName,\n\tlabelClassName,\n\tvalueClassName,\n\tpercentageClassName,\n\tshowPercentages = true,\n\tshowTotalRow = true,\n\ttotalLabel = 'Total',\n\ttotalFormatter,\n\tpercentageFormatter,\n}: PieChartDataTableContentProps<TData>) {\n\tconst { slices, total, formatLabel, formatValue } =\n\t\tusePieChartContext<TData>();\n\n\tif (!slices.length) {\n\t\treturn null;\n\t}\n\n\tconst baseRowClass = showPercentages\n\t\t? 'grid grid-cols-[minmax(0,1fr)_auto_auto] items-center gap-3'\n\t\t: 'grid grid-cols-[minmax(0,1fr)_auto] items-center gap-3';\n\n\tconst totalRowBaseClass = showPercentages\n\t\t? 'grid grid-cols-[minmax(0,1fr)_auto_auto] items-center gap-3 border-t border-border/60 pt-3 text-sm font-medium text-foreground'\n\t\t: 'grid grid-cols-[minmax(0,1fr)_auto] items-center gap-3 border-t border-border/60 pt-3 text-sm font-medium text-foreground';\n\n\tconst renderPercentage = (slice: PieChartSlice<TData>) => {\n\t\tif (!showPercentages) return null;\n\n\t\tconst content =\n\t\t\tpercentageFormatter?.(slice.percentage, slice) ??\n\t\t\t`${(slice.percentage * 100).toFixed(1)}%`;\n\n\t\treturn (\n\t\t\t<span\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'text-right text-xs uppercase tracking-wide text-foreground/45',\n\t\t\t\t\tpercentageClassName,\n\t\t\t\t)}\n\t\t\t>\n\t\t\t\t{content}\n\t\t\t</span>\n\t\t);\n\t};\n\n\tconst resolvedTotal = totalFormatter?.(total) ?? total.toLocaleString();\n\n\treturn (\n\t\t<div className={cn('space-y-2', className)}>\n\t\t\t{slices.map((slice) => (\n\t\t\t\t<div key={slice.id} className={cn(baseRowClass, rowClassName)}>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t'flex items-center gap-2 text-foreground/70',\n\t\t\t\t\t\t\tlabelClassName,\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName=\"inline-flex h-2.5 w-1 shrink-0 rounded-[1px]\"\n\t\t\t\t\t\t\tstyle={{ backgroundColor: slice.color }}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<span className=\"truncate text-sm font-medium\">\n\t\t\t\t\t\t\t{formatLabel(slice)}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<span\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t'text-right text-sm font-medium text-foreground/70',\n\t\t\t\t\t\t\tvalueClassName,\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{formatValue(slice)}\n\t\t\t\t\t</span>\n\t\t\t\t\t{renderPercentage(slice)}\n\t\t\t\t</div>\n\t\t\t))}\n\t\t\t{showTotalRow ? (\n\t\t\t\t<div className={cn(totalRowBaseClass, rowClassName)}>\n\t\t\t\t\t<span>{totalLabel}</span>\n\t\t\t\t\t<span className={cn('text-right', valueClassName)}>\n\t\t\t\t\t\t{resolvedTotal}\n\t\t\t\t\t</span>\n\t\t\t\t\t{showPercentages ? (\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t'text-right text-xs uppercase tracking-wide text-foreground/45',\n\t\t\t\t\t\t\t\tpercentageClassName,\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t100%\n\t\t\t\t\t\t</span>\n\t\t\t\t\t) : null}\n\t\t\t\t</div>\n\t\t\t) : null}\n\t\t</div>\n\t);\n}\n\nexport const PieChart = PieChartRoot;\n",
      "type": "registry:component"
    }
  ]
}