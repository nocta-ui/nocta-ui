{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "toast",
  "type": "registry:component",
  "title": "Toast",
  "description": "Advanced toast notification system with observer pattern, CSS transition animations, positioning, and stacking",
  "dependencies": [
    "class-variance-authority",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/toast.tsx",
      "content": "'use client';\n\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport React, {\n\tuseCallback,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseMemo,\n\tuseRef,\n\tuseState,\n} from 'react';\nimport { cn } from '@/lib/utils';\nimport { Icons } from '@/registry/ui/nocta-icons';\n\nconst POSITION_CONFIGS = {\n\t'top-left': {\n\t\tanimateIn: { x: -100, y: -20 },\n\t\tanimateOut: { x: -100, y: -20 },\n\t},\n\t'top-center': {\n\t\tanimateIn: { x: 0, y: -100 },\n\t\tanimateOut: { x: 0, y: -100 },\n\t},\n\t'top-right': {\n\t\tanimateIn: { x: 100, y: -20 },\n\t\tanimateOut: { x: 100, y: -20 },\n\t},\n\t'bottom-left': {\n\t\tanimateIn: { x: -100, y: 20 },\n\t\tanimateOut: { x: -100, y: 100 },\n\t},\n\t'bottom-center': {\n\t\tanimateIn: { x: 0, y: 100 },\n\t\tanimateOut: { x: 0, y: 100 },\n\t},\n\t'bottom-right': {\n\t\tanimateIn: { x: 100, y: 20 },\n\t\tanimateOut: { x: 100, y: 100 },\n\t},\n} as const;\n\nconst FOCUSABLE_SELECTORS = [\n\t'button:not([disabled])',\n\t'input:not([disabled])',\n\t'textarea:not([disabled])',\n\t'select:not([disabled])',\n\t'a[href]',\n\t'[tabindex]:not([tabindex=\"-1\"])',\n].join(', ');\n\nconst ANIMATION_CONFIG = {\n\tENTER_DURATION: 0.75,\n\tEXIT_DURATION: 0.75,\n\tSTACK_DURATION: 0.75,\n\tSTACK_OFFSET: 16,\n\tEXPANDED_GAP: 12,\n\tSCALE_FACTOR: 0.04,\n\tMIN_SCALE: 0.92,\n\tMAX_VISIBLE_TOASTS: 3,\n\tZ_INDEX_BASE: 50,\n\tEASING_DEFAULT: 'var(--ease-smooth)',\n\tEASING_EXIT: 'var(--ease-smooth)',\n} as const;\n\nconst SWIPE_DISMISS_THRESHOLD = 45;\nconst SWIPE_DISMISS_VELOCITY = 0.11;\nconst SWIPE_EXIT_DISTANCE = 600;\n\ntype SwipeDirection = 'top' | 'bottom' | 'left' | 'right';\ntype SwipeAxis = 'x' | 'y';\n\ntype ToastSubscriber = (toasts: ToastData[]) => void;\n\nclass ToastState {\n\tprivate toasts: ToastData[] = [];\n\tprivate subscribers: Set<ToastSubscriber> = new Set();\n\tprivate idCounter = 0;\n\n\tsubscribe(callback: ToastSubscriber): () => void {\n\t\tthis.subscribers.add(callback);\n\t\treturn () => {\n\t\t\tthis.subscribers.delete(callback);\n\t\t};\n\t}\n\n\tprivate notify(): void {\n\t\tthis.subscribers.forEach((callback) => {\n\t\t\tcallback([...this.toasts]);\n\t\t});\n\t}\n\n\tprivate generateId(): string {\n\t\treturn `toast-${Date.now()}-${++this.idCounter}`;\n\t}\n\n\tadd(data: Omit<ToastData, 'id'>): string {\n\t\tconst id = this.generateId();\n\t\tconst newToast: ToastData = { ...data, id };\n\t\tthis.toasts = [newToast, ...this.toasts];\n\t\tthis.notify();\n\t\treturn id;\n\t}\n\n\tremove(id: string): void {\n\t\tthis.toasts = this.toasts.filter((toast) => toast.id !== id);\n\t\tthis.notify();\n\t}\n\n\tupdate(id: string, data: Partial<ToastData>): void {\n\t\tthis.toasts = this.toasts.map((toast) =>\n\t\t\ttoast.id === id ? { ...toast, ...data } : toast,\n\t\t);\n\t\tthis.notify();\n\t}\n\n\tdismissAll(): void {\n\t\tthis.toasts = this.toasts.map((toast) => ({\n\t\t\t...toast,\n\t\t\tshouldClose: true,\n\t\t\tduration: 0,\n\t\t}));\n\t\tthis.notify();\n\t}\n\n\tgetToasts(): ToastData[] {\n\t\treturn [...this.toasts];\n\t}\n}\n\nconst toastState = new ToastState();\n\nclass ToasterInstanceManager {\n\tprivate activeInstanceId: string | null = null;\n\tprivate instanceCounter = 0;\n\n\tregisterInstance(): string {\n\t\tconst instanceId = `toaster-${++this.instanceCounter}`;\n\t\tif (!this.activeInstanceId) {\n\t\t\tthis.activeInstanceId = instanceId;\n\t\t}\n\t\treturn instanceId;\n\t}\n\n\tunregisterInstance(instanceId: string): void {\n\t\tif (this.activeInstanceId === instanceId) {\n\t\t\tthis.activeInstanceId = null;\n\t\t}\n\t}\n\n\tisActiveInstance(instanceId: string): boolean {\n\t\treturn this.activeInstanceId === instanceId;\n\t}\n}\n\nconst toasterInstanceManager = new ToasterInstanceManager();\n\nconst toastContainerVariants = cva(\n\t'pointer-events-auto fixed rounded-lg border shadow-2xl card-highlight will-change-transform border-border bg-popover',\n\t{\n\t\tvariants: {\n\t\t\tposition: {\n\t\t\t\t'top-left': 'top-4 left-4 w-full max-w-sm',\n\t\t\t\t'top-center':\n\t\t\t\t\t'top-4 left-1/2 w-full max-w-sm -translate-x-1/2 transform',\n\t\t\t\t'top-right': 'top-4 right-4 w-full max-w-sm',\n\t\t\t\t'bottom-left': 'bottom-4 left-4 w-full max-w-sm',\n\t\t\t\t'bottom-center':\n\t\t\t\t\t'bottom-4 left-1/2 w-full max-w-sm -translate-x-1/2 transform',\n\t\t\t\t'bottom-right': 'right-4 bottom-4 w-full max-w-sm',\n\t\t\t},\n\t\t\tvariant: {\n\t\t\t\tdefault: 'text-foreground',\n\t\t\t\tsuccess: 'text-success/90',\n\t\t\t\twarning: 'text-warning/90',\n\t\t\t\tdestructive: 'text-destructive/90',\n\t\t\t},\n\t\t},\n\t\tdefaultVariants: {\n\t\t\tposition: 'bottom-center',\n\t\t\tvariant: 'default',\n\t\t},\n\t},\n);\n\nconst toastContentVariants = cva('relative overflow-hidden rounded-lg', {\n\tvariants: {\n\t\tvariant: {\n\t\t\tdefault: '',\n\t\t\tsuccess: '',\n\t\t\twarning: '',\n\t\t\tdestructive: '',\n\t\t},\n\t},\n\tdefaultVariants: {\n\t\tvariant: 'default',\n\t},\n});\n\nexport type ToastPosition =\n\t| 'top-left'\n\t| 'top-center'\n\t| 'top-right'\n\t| 'bottom-left'\n\t| 'bottom-center'\n\t| 'bottom-right';\n\nconst getDefaultSwipeDirections = (\n\tposition?: ToastPosition | null,\n): SwipeDirection[] => {\n\tif (!position) {\n\t\treturn ['top', 'bottom', 'left', 'right'];\n\t}\n\n\tconst [vertical, horizontal] = position.split('-') as [\n\t\tstring,\n\t\tstring | undefined,\n\t];\n\tconst directions: SwipeDirection[] = [];\n\n\tif (vertical === 'top' || vertical === 'bottom') {\n\t\tdirections.push(vertical);\n\t}\n\n\tif (horizontal === 'left' || horizontal === 'right') {\n\t\tdirections.push(horizontal);\n\t}\n\n\tif (directions.length === 0) {\n\t\tdirections.push('top', 'bottom');\n\t}\n\n\treturn directions;\n};\n\nexport interface ToastData extends VariantProps<typeof toastContainerVariants> {\n\tid: string;\n\ttitle?: string;\n\tdescription?: string;\n\tclassName?: string;\n\tduration?: number;\n\taction?: {\n\t\tlabel: string;\n\t\tonClick: () => void;\n\t};\n\tonClose?: () => void;\n\tshouldClose?: boolean;\n\tisLeaving?: boolean;\n}\n\nexport const toast = (data: Omit<ToastData, 'id'> | string): string => {\n\tif (typeof data === 'string') {\n\t\treturn toastState.add({ description: data });\n\t}\n\treturn toastState.add(data);\n};\n\ntoast.success = (data: Omit<ToastData, 'id' | 'variant'> | string): string => {\n\tif (typeof data === 'string') {\n\t\treturn toastState.add({ description: data, variant: 'success' });\n\t}\n\treturn toastState.add({ ...data, variant: 'success' });\n};\n\ntoast.warning = (data: Omit<ToastData, 'id' | 'variant'> | string): string => {\n\tif (typeof data === 'string') {\n\t\treturn toastState.add({ description: data, variant: 'warning' });\n\t}\n\treturn toastState.add({ ...data, variant: 'warning' });\n};\n\ntoast.error = (data: Omit<ToastData, 'id' | 'variant'> | string): string => {\n\tif (typeof data === 'string') {\n\t\treturn toastState.add({ description: data, variant: 'destructive' });\n\t}\n\treturn toastState.add({ ...data, variant: 'destructive' });\n};\n\ntoast.dismiss = (id: string): void => {\n\ttoastState.update(id, { shouldClose: true });\n};\n\ntoast.dismissAll = (): void => {\n\ttoastState.dismissAll();\n};\n\ntype PositionedToast = ToastData & {\n\tindex: number;\n\trenderIndex: number;\n\ttotal: number;\n};\n\ninterface ToastItemProps {\n\ttoast: PositionedToast;\n\tonRemove: (id: string) => void;\n\tisGroupHovered?: boolean;\n\texpandedOffset?: number;\n\texpandedGap?: number;\n\tcollapsedOffset?: number;\n\thiddenCollapsedOffset?: number;\n\tonHeightChange?: (id: string, height: number) => void;\n\tonGroupHoverEnter?: () => void;\n}\n\nconst ToastItem: React.FC<ToastItemProps> = React.memo(\n\t({\n\t\ttoast,\n\t\tonRemove,\n\t\tisGroupHovered = false,\n\t\texpandedOffset = 0,\n\t\texpandedGap = ANIMATION_CONFIG.EXPANDED_GAP,\n\t\tcollapsedOffset,\n\t\thiddenCollapsedOffset,\n\t\tonHeightChange,\n\t\tonGroupHoverEnter,\n\t}) => {\n\t\tconst toastRef = useRef<HTMLDivElement>(null);\n\t\tconst timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\t\tconst timerStartRef = useRef<number | null>(null);\n\t\tconst remainingRef = useRef<number>(Number.NaN);\n\t\tconst enterAnimationRef = useRef<number | null>(null);\n\t\tconst isExiting = useRef(false);\n\t\tconst exitAnimationCompleteRef = useRef(false);\n\t\tconst hasAnimatedIn = useRef(false);\n\t\tconst pointerStartRef = useRef<{ x: number; y: number } | null>(null);\n\t\tconst dragStartTimeRef = useRef<number | null>(null);\n\t\tconst swipeAxisRef = useRef<SwipeAxis | null>(null);\n\t\tconst lastSwipeRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });\n\t\tconst [isItemHovered, setIsItemHovered] = useState(false);\n\t\tconst [isSwiping, setIsSwiping] = useState(false);\n\t\tconst [swipeDismissDirection, setSwipeDismissDirection] =\n\t\t\tuseState<SwipeDirection | null>(null);\n\t\tconst [animationState, setAnimationState] = useState<\n\t\t\t'entering' | 'entered' | 'exiting' | 'stacking'\n\t\t>('entering');\n\n\t\tconst {\n\t\t\tid,\n\t\t\ttitle,\n\t\t\tdescription,\n\t\t\tvariant = 'default',\n\t\t\tduration = 5000,\n\t\t\taction,\n\t\t\tindex,\n\t\t\trenderIndex,\n\t\t\tshouldClose,\n\t\t\tposition = 'bottom-center',\n\t\t\tclassName = '',\n\t\t\tonClose,\n\t\t} = toast;\n\n\t\tconst titleId = title ? `${id}-title` : undefined;\n\t\tconst descriptionId = description ? `${id}-desc` : undefined;\n\t\tconst liveRole = variant === 'destructive' ? 'alert' : 'status';\n\t\tconst livePoliteness = variant === 'destructive' ? 'assertive' : 'polite';\n\n\t\tconst config = POSITION_CONFIGS[position as keyof typeof POSITION_CONFIGS];\n\n\t\tconst swipeDirections = useMemo(\n\t\t\t() => getDefaultSwipeDirections(position),\n\t\t\t[position],\n\t\t);\n\n\t\tconst clearSwipeRefs = useCallback(() => {\n\t\t\tpointerStartRef.current = null;\n\t\t\tdragStartTimeRef.current = null;\n\t\t\tswipeAxisRef.current = null;\n\t\t\tlastSwipeRef.current = { x: 0, y: 0 };\n\t\t}, []);\n\n\t\tuseLayoutEffect(() => {\n\t\t\tif (!toastRef.current) return;\n\t\t\tconst el = toastRef.current;\n\t\t\tconst notify = () => {\n\t\t\t\tif (!onHeightChange) return;\n\t\t\t\tonHeightChange(id, el.offsetHeight);\n\t\t\t};\n\t\t\tnotify();\n\t\t\tconst ro = new ResizeObserver(() => notify());\n\t\t\tro.observe(el);\n\t\t\treturn () => ro.disconnect();\n\t\t}, [id, onHeightChange]);\n\n\t\tconst getFocusableElements = useCallback(() => {\n\t\t\tif (!toastRef.current) return [];\n\t\t\treturn Array.from(\n\t\t\t\ttoastRef.current.querySelectorAll(FOCUSABLE_SELECTORS),\n\t\t\t) as HTMLElement[];\n\t\t}, []);\n\n\t\tconst handleTransitionEnd = useCallback(\n\t\t\t(e: React.TransitionEvent) => {\n\t\t\t\tif (e.target !== toastRef.current) return;\n\t\t\t\tif (e.propertyName !== 'opacity' && e.propertyName !== 'transform')\n\t\t\t\t\treturn;\n\t\t\t\tif (animationState !== 'exiting') return;\n\t\t\t\tif (exitAnimationCompleteRef.current) return;\n\n\t\t\t\texitAnimationCompleteRef.current = true;\n\t\t\t\tonClose?.();\n\t\t\t\tonRemove(id);\n\t\t\t},\n\t\t\t[animationState, id, onRemove, onClose],\n\t\t);\n\n\t\tconst handleClose = useCallback(() => {\n\t\t\tif (!toastRef.current || isExiting.current) return;\n\n\t\t\tisExiting.current = true;\n\t\t\texitAnimationCompleteRef.current = false;\n\n\t\t\ttoastState.update(id, { shouldClose: true });\n\n\t\t\tif (enterAnimationRef.current) {\n\t\t\t\tcancelAnimationFrame(enterAnimationRef.current);\n\t\t\t\tenterAnimationRef.current = null;\n\t\t\t}\n\n\t\t\tif (timeoutRef.current) {\n\t\t\t\tclearTimeout(timeoutRef.current);\n\t\t\t\ttimeoutRef.current = null;\n\t\t\t}\n\n\t\t\tsetAnimationState('exiting');\n\t\t\ttoastState.update(id, { shouldClose: true, isLeaving: true });\n\t\t}, [id]);\n\n\t\tuseEffect(() => {\n\t\t\tif (shouldClose) {\n\t\t\t\thandleClose();\n\t\t\t}\n\t\t}, [shouldClose, handleClose]);\n\n\t\tconst stackHidden = index >= ANIMATION_CONFIG.MAX_VISIBLE_TOASTS;\n\t\tconst hiddenByStacking = stackHidden && animationState !== 'exiting';\n\t\tconst isStackLeader = index === 0;\n\t\tconst isLatest = isStackLeader && !shouldClose;\n\n\t\tuseEffect(() => {\n\t\t\tif (isSwiping) return;\n\t\t\tif (swipeDismissDirection) return;\n\t\t\tconst node = toastRef.current;\n\t\t\tif (!node) return;\n\t\t\tnode.style.setProperty('--swipe-translate-x', '0px');\n\t\t\tnode.style.setProperty('--swipe-translate-y', '0px');\n\t\t}, [isSwiping, swipeDismissDirection]);\n\n\t\tuseLayoutEffect(() => {\n\t\t\tif (!toastRef.current || isExiting.current) return;\n\n\t\t\tconst element = toastRef.current;\n\n\t\t\tconst setFocusToToast = () => {\n\t\t\t\tif (!isLatest) return;\n\t\t\t\tconst focusableElements = getFocusableElements();\n\t\t\t\tconst firstFocusable = focusableElements[0];\n\t\t\t\tif (firstFocusable) {\n\t\t\t\t\tfirstFocusable.focus();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telement.focus();\n\t\t\t};\n\n\t\t\tif (!hasAnimatedIn.current && isLatest) {\n\t\t\t\thasAnimatedIn.current = true;\n\t\t\t\tsetAnimationState('entering');\n\n\t\t\t\tenterAnimationRef.current = requestAnimationFrame(() => {\n\t\t\t\t\tenterAnimationRef.current = requestAnimationFrame(() => {\n\t\t\t\t\t\tsetAnimationState('entered');\n\t\t\t\t\t\tif (action) {\n\t\t\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\t\t\tsetFocusToToast,\n\t\t\t\t\t\t\t\tANIMATION_CONFIG.ENTER_DURATION * 1000,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else if (hasAnimatedIn.current) {\n\t\t\t\tif (animationState !== 'stacking' || index > 0) {\n\t\t\t\t\tsetAnimationState('stacking');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetAnimationState('stacking');\n\t\t\t}\n\t\t}, [index, getFocusableElements, animationState, action, isLatest]);\n\n\t\tuseEffect(() => {\n\t\t\tif (shouldClose || !hasAnimatedIn.current) return;\n\t\t\tif (duration <= 0) return;\n\n\t\t\tif (remainingRef.current == null || Number.isNaN(remainingRef.current)) {\n\t\t\t\tremainingRef.current = duration;\n\t\t\t}\n\n\t\t\tconst isPaused =\n\t\t\t\tisGroupHovered || isItemHovered || isSwiping || hiddenByStacking;\n\t\t\tif (isPaused) {\n\t\t\t\tif (timeoutRef.current) {\n\t\t\t\t\tclearTimeout(timeoutRef.current);\n\t\t\t\t\ttimeoutRef.current = null;\n\t\t\t\t}\n\t\t\t\tif (timerStartRef.current !== null) {\n\t\t\t\t\tconst elapsed = Date.now() - timerStartRef.current;\n\t\t\t\t\tremainingRef.current = Math.max(0, remainingRef.current - elapsed);\n\t\t\t\t\ttimerStartRef.current = null;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!timeoutRef.current) {\n\t\t\t\tconst ms = Math.max(0, remainingRef.current ?? duration);\n\t\t\t\tif (ms === 0) {\n\t\t\t\t\thandleClose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttimerStartRef.current = Date.now();\n\t\t\t\ttimeoutRef.current = setTimeout(() => {\n\t\t\t\t\thandleClose();\n\t\t\t\t}, ms);\n\t\t\t}\n\n\t\t\treturn () => {\n\t\t\t\tif (timeoutRef.current) {\n\t\t\t\t\tclearTimeout(timeoutRef.current);\n\t\t\t\t\tif (timerStartRef.current !== null) {\n\t\t\t\t\t\tconst elapsed = Date.now() - timerStartRef.current;\n\t\t\t\t\t\tremainingRef.current = Math.max(0, remainingRef.current - elapsed);\n\t\t\t\t\t}\n\t\t\t\t\ttimeoutRef.current = null;\n\t\t\t\t\ttimerStartRef.current = null;\n\t\t\t\t}\n\t\t\t};\n\t\t}, [\n\t\t\tduration,\n\t\t\tshouldClose,\n\t\t\thandleClose,\n\t\t\tisGroupHovered,\n\t\t\tisItemHovered,\n\t\t\tisSwiping,\n\t\t\thiddenByStacking,\n\t\t]);\n\n\t\tuseEffect(() => {\n\t\t\tremainingRef.current = duration;\n\t\t}, [duration]);\n\n\t\tuseEffect(() => {\n\t\t\treturn () => {\n\t\t\t\tif (enterAnimationRef.current) {\n\t\t\t\t\tcancelAnimationFrame(enterAnimationRef.current);\n\t\t\t\t}\n\t\t\t\tif (timeoutRef.current) {\n\t\t\t\t\tclearTimeout(timeoutRef.current);\n\t\t\t\t}\n\t\t\t};\n\t\t}, []);\n\n\t\tconst isTopPosition = position?.startsWith('top-');\n\t\tconst maxVisibleIndex = Math.max(\n\t\t\t0,\n\t\t\tANIMATION_CONFIG.MAX_VISIBLE_TOASTS - 1,\n\t\t);\n\t\tconst visibleIndex = Math.min(index, maxVisibleIndex);\n\t\tconst defaultCollapsedOffset = isTopPosition\n\t\t\t? index * ANIMATION_CONFIG.STACK_OFFSET\n\t\t\t: -(index * ANIMATION_CONFIG.STACK_OFFSET);\n\t\tconst resolvedCollapsedOffset =\n\t\t\ttypeof collapsedOffset === 'number' && Number.isFinite(collapsedOffset)\n\t\t\t\t? collapsedOffset\n\t\t\t\t: defaultCollapsedOffset;\n\t\tconst resolvedHiddenCollapsedOffset =\n\t\t\ttypeof hiddenCollapsedOffset === 'number' &&\n\t\t\tNumber.isFinite(hiddenCollapsedOffset)\n\t\t\t\t? hiddenCollapsedOffset\n\t\t\t\t: resolvedCollapsedOffset;\n\t\tconst scale = Math.max(\n\t\t\tANIMATION_CONFIG.MIN_SCALE,\n\t\t\t1 - index * ANIMATION_CONFIG.SCALE_FACTOR,\n\t\t);\n\t\tconst visibleScale = Math.max(\n\t\t\tANIMATION_CONFIG.MIN_SCALE,\n\t\t\t1 - visibleIndex * ANIMATION_CONFIG.SCALE_FACTOR,\n\t\t);\n\t\tconst zIndex = ANIMATION_CONFIG.Z_INDEX_BASE - renderIndex;\n\n\t\tconst transformStyle = useMemo(() => {\n\t\t\tconst baseOffsetY = stackHidden\n\t\t\t\t? resolvedHiddenCollapsedOffset\n\t\t\t\t: resolvedCollapsedOffset;\n\t\t\tconst promotionOffset =\n\t\t\t\ttypeof expandedGap === 'number'\n\t\t\t\t\t? expandedGap\n\t\t\t\t\t: ANIMATION_CONFIG.EXPANDED_GAP;\n\t\t\tconst expandedTranslateY = isTopPosition\n\t\t\t\t? expandedOffset\n\t\t\t\t: -expandedOffset;\n\t\t\tconst hiddenExpandedTranslateY = expandedTranslateY - promotionOffset;\n\n\t\t\tlet translateX = 0;\n\t\t\tlet translateY = baseOffsetY;\n\t\t\tlet scaleValue = stackHidden\n\t\t\t\t? visibleIndex === 0\n\t\t\t\t\t? 1\n\t\t\t\t\t: visibleScale\n\t\t\t\t: isStackLeader\n\t\t\t\t\t? 1\n\t\t\t\t\t: scale;\n\t\t\tlet opacityValue = stackHidden ? 0 : 1;\n\n\t\t\tif (stackHidden) {\n\t\t\t\tif (isGroupHovered && animationState !== 'exiting') {\n\t\t\t\t\ttranslateX = 0;\n\t\t\t\t\ttranslateY = hiddenExpandedTranslateY;\n\t\t\t\t\tscaleValue = 1;\n\t\t\t\t}\n\t\t\t} else if (isGroupHovered && animationState !== 'exiting') {\n\t\t\t\ttranslateX = 0;\n\t\t\t\ttranslateY = expandedTranslateY;\n\t\t\t\tscaleValue = 1;\n\t\t\t\topacityValue = 1;\n\t\t\t} else {\n\t\t\t\tswitch (animationState) {\n\t\t\t\t\tcase 'entering':\n\t\t\t\t\t\ttranslateX = config.animateIn.x;\n\t\t\t\t\t\ttranslateY = config.animateIn.y;\n\t\t\t\t\t\tscaleValue = 1;\n\t\t\t\t\t\topacityValue = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'entered':\n\t\t\t\t\t\ttranslateX = 0;\n\t\t\t\t\t\ttranslateY = baseOffsetY;\n\t\t\t\t\t\tscaleValue = 1;\n\t\t\t\t\t\topacityValue = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'exiting': {\n\t\t\t\t\t\tscaleValue = 1;\n\t\t\t\t\t\topacityValue = 0;\n\t\t\t\t\t\tif (swipeDismissDirection) {\n\t\t\t\t\t\t\tswitch (swipeDismissDirection) {\n\t\t\t\t\t\t\t\tcase 'left':\n\t\t\t\t\t\t\t\t\ttranslateX = -SWIPE_EXIT_DISTANCE;\n\t\t\t\t\t\t\t\t\ttranslateY = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'right':\n\t\t\t\t\t\t\t\t\ttranslateX = SWIPE_EXIT_DISTANCE;\n\t\t\t\t\t\t\t\t\ttranslateY = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t\t\t\ttranslateX = 0;\n\t\t\t\t\t\t\t\t\ttranslateY = -SWIPE_EXIT_DISTANCE;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\t\t\ttranslateX = 0;\n\t\t\t\t\t\t\t\t\ttranslateY = SWIPE_EXIT_DISTANCE;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\ttranslateX = config.animateOut.x;\n\t\t\t\t\t\t\t\t\ttranslateY = config.animateOut.y;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttranslateX = config.animateOut.x;\n\t\t\t\t\t\t\ttranslateY = config.animateOut.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttranslateX = 0;\n\t\t\t\t\t\ttranslateY = baseOffsetY;\n\t\t\t\t\t\tscaleValue = isStackLeader ? 1 : scale;\n\t\t\t\t\t\topacityValue = stackHidden ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst transform = `translate(calc(${translateX}px + var(--swipe-translate-x, 0px)), calc(${translateY}px + var(--swipe-translate-y, 0px))) scale(${scaleValue})`;\n\n\t\t\treturn {\n\t\t\t\ttransform,\n\t\t\t\topacity: opacityValue,\n\t\t\t};\n\t\t}, [\n\t\t\tanimationState,\n\t\t\tconfig.animateIn.x,\n\t\t\tconfig.animateIn.y,\n\t\t\tconfig.animateOut.x,\n\t\t\tconfig.animateOut.y,\n\t\t\texpandedOffset,\n\t\t\tisGroupHovered,\n\t\t\tisStackLeader,\n\t\t\tisTopPosition,\n\t\t\tvisibleIndex,\n\t\t\tvisibleScale,\n\t\t\tstackHidden,\n\t\t\tresolvedCollapsedOffset,\n\t\t\tresolvedHiddenCollapsedOffset,\n\t\t\texpandedGap,\n\t\t\tscale,\n\t\t\tswipeDismissDirection,\n\t\t]);\n\n\t\tconst transitionDuration = useMemo(() => {\n\t\t\tswitch (animationState) {\n\t\t\t\tcase 'entering':\n\t\t\t\tcase 'entered':\n\t\t\t\t\treturn `${ANIMATION_CONFIG.ENTER_DURATION}s`;\n\t\t\t\tcase 'exiting':\n\t\t\t\t\treturn `${ANIMATION_CONFIG.EXIT_DURATION}s`;\n\t\t\t\tdefault:\n\t\t\t\t\treturn `${ANIMATION_CONFIG.STACK_DURATION}s`;\n\t\t\t}\n\t\t}, [animationState]);\n\n\t\tconst transitionTimingFunction = useMemo(() => {\n\t\t\treturn animationState === 'exiting'\n\t\t\t\t? ANIMATION_CONFIG.EASING_EXIT\n\t\t\t\t: ANIMATION_CONFIG.EASING_DEFAULT;\n\t\t}, [animationState]);\n\n\t\tconst canSwipe = swipeDirections.length > 0;\n\t\tconst swipeCursorClass = canSwipe\n\t\t\t? isSwiping\n\t\t\t\t? 'cursor-grabbing'\n\t\t\t\t: 'cursor-grab'\n\t\t\t: undefined;\n\n\t\tconst handlePointerDown = useCallback(\n\t\t\t(event: React.PointerEvent<HTMLDivElement>) => {\n\t\t\t\tif (event.pointerType === 'mouse' && event.button !== 0) return;\n\t\t\t\tif (event.button === 2) return;\n\t\t\t\tif (isExiting.current) return;\n\n\t\t\t\tconst target = event.target as HTMLElement;\n\t\t\t\tif (target.closest('button, a, input, textarea, select')) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tclearSwipeRefs();\n\t\t\t\tpointerStartRef.current = { x: event.clientX, y: event.clientY };\n\t\t\t\tdragStartTimeRef.current = Date.now();\n\t\t\t\tconst node = toastRef.current;\n\t\t\t\tif (node) {\n\t\t\t\t\tnode.style.setProperty('--swipe-translate-x', '0px');\n\t\t\t\t\tnode.style.setProperty('--swipe-translate-y', '0px');\n\t\t\t\t}\n\t\t\t\tsetSwipeDismissDirection(null);\n\t\t\t\tsetIsSwiping(true);\n\t\t\t\tevent.currentTarget.setPointerCapture(event.pointerId);\n\t\t\t},\n\t\t\t[clearSwipeRefs],\n\t\t);\n\n\t\tconst handlePointerMove = useCallback(\n\t\t\t(event: React.PointerEvent<HTMLDivElement>) => {\n\t\t\t\tif (!pointerStartRef.current) return;\n\t\t\t\tif (isExiting.current) return;\n\n\t\t\t\tif (event.pointerType === 'touch') {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\n\t\t\t\tconst xDelta = event.clientX - pointerStartRef.current.x;\n\t\t\t\tconst yDelta = event.clientY - pointerStartRef.current.y;\n\n\t\t\t\tlet axis = swipeAxisRef.current;\n\t\t\t\tif (!axis) {\n\t\t\t\t\tif (Math.abs(xDelta) > 1 || Math.abs(yDelta) > 1) {\n\t\t\t\t\t\taxis = Math.abs(xDelta) > Math.abs(yDelta) ? 'x' : 'y';\n\t\t\t\t\t\tswipeAxisRef.current = axis;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dampen = (delta: number) => {\n\t\t\t\t\tconst factor = Math.abs(delta) / 20;\n\t\t\t\t\treturn delta * (1 / (1.5 + factor));\n\t\t\t\t};\n\n\t\t\t\tlet nextX = 0;\n\t\t\t\tlet nextY = 0;\n\n\t\t\t\tif (axis === 'x') {\n\t\t\t\t\tconst allowLeft = swipeDirections.includes('left');\n\t\t\t\t\tconst allowRight = swipeDirections.includes('right');\n\t\t\t\t\tif (!allowLeft && !allowRight) {\n\t\t\t\t\t\tswipeAxisRef.current = 'y';\n\t\t\t\t\t\taxis = 'y';\n\t\t\t\t\t} else if ((allowLeft && xDelta < 0) || (allowRight && xDelta > 0)) {\n\t\t\t\t\t\tnextX = xDelta;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextX = dampen(xDelta);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (axis === 'y') {\n\t\t\t\t\tconst allowTop = swipeDirections.includes('top');\n\t\t\t\t\tconst allowBottom = swipeDirections.includes('bottom');\n\t\t\t\t\tif (!allowTop && !allowBottom) {\n\t\t\t\t\t\tswipeAxisRef.current = 'x';\n\t\t\t\t\t\taxis = 'x';\n\t\t\t\t\t} else if ((allowTop && yDelta < 0) || (allowBottom && yDelta > 0)) {\n\t\t\t\t\t\tnextY = yDelta;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextY = dampen(yDelta);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlastSwipeRef.current = { x: nextX, y: nextY };\n\t\t\t\tconst node = toastRef.current;\n\t\t\t\tif (node) {\n\t\t\t\t\tnode.style.setProperty('--swipe-translate-x', `${nextX}px`);\n\t\t\t\t\tnode.style.setProperty('--swipe-translate-y', `${nextY}px`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t[swipeDirections],\n\t\t);\n\n\t\tconst handlePointerUp = useCallback(\n\t\t\t(event: React.PointerEvent<HTMLDivElement>) => {\n\t\t\t\tif (event.currentTarget.hasPointerCapture(event.pointerId)) {\n\t\t\t\t\tevent.currentTarget.releasePointerCapture(event.pointerId);\n\t\t\t\t}\n\n\t\t\t\tif (!pointerStartRef.current) {\n\t\t\t\t\tsetSwipeDismissDirection(null);\n\t\t\t\t\tsetIsSwiping(false);\n\t\t\t\t\tclearSwipeRefs();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst elapsed = dragStartTimeRef.current\n\t\t\t\t\t? Date.now() - dragStartTimeRef.current\n\t\t\t\t\t: 0;\n\n\t\t\t\tconst axis = swipeAxisRef.current;\n\t\t\t\tconst { x, y } = lastSwipeRef.current;\n\t\t\t\tlet dismissed = false;\n\n\t\t\t\tif (axis) {\n\t\t\t\t\tconst distance = axis === 'x' ? x : y;\n\t\t\t\t\tconst velocity = elapsed > 0 ? Math.abs(distance) / elapsed : 0;\n\t\t\t\t\tconst meetsThreshold =\n\t\t\t\t\t\tMath.abs(distance) >= SWIPE_DISMISS_THRESHOLD ||\n\t\t\t\t\t\tvelocity > SWIPE_DISMISS_VELOCITY;\n\n\t\t\t\t\tif (meetsThreshold && Math.abs(distance) > 0) {\n\t\t\t\t\t\tlet direction: SwipeDirection;\n\t\t\t\t\t\tif (axis === 'x') {\n\t\t\t\t\t\t\tdirection = distance > 0 ? 'right' : 'left';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdirection = distance > 0 ? 'bottom' : 'top';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (swipeDirections.includes(direction)) {\n\t\t\t\t\t\t\tsetSwipeDismissDirection(direction);\n\t\t\t\t\t\t\tdismissed = true;\n\t\t\t\t\t\t\thandleClose();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!dismissed) {\n\t\t\t\t\tsetSwipeDismissDirection(null);\n\t\t\t\t}\n\n\t\t\t\tsetIsSwiping(false);\n\t\t\t\tclearSwipeRefs();\n\t\t\t},\n\t\t\t[clearSwipeRefs, handleClose, swipeDirections],\n\t\t);\n\n\t\tconst handlePointerCancel = useCallback(\n\t\t\t(event: React.PointerEvent<HTMLDivElement>) => {\n\t\t\t\tif (event.currentTarget.hasPointerCapture(event.pointerId)) {\n\t\t\t\t\tevent.currentTarget.releasePointerCapture(event.pointerId);\n\t\t\t\t}\n\t\t\t\tsetSwipeDismissDirection(null);\n\t\t\t\tsetIsSwiping(false);\n\t\t\t\tclearSwipeRefs();\n\t\t\t},\n\t\t\t[clearSwipeRefs],\n\t\t);\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={toastRef}\n\t\t\t\tclassName={cn(\n\t\t\t\t\ttoastContainerVariants({ position, variant }),\n\t\t\t\t\tclassName,\n\t\t\t\t\tswipeCursorClass,\n\t\t\t\t\tstackHidden && 'pointer-events-none',\n\t\t\t\t)}\n\t\t\t\tstyle={{\n\t\t\t\t\ttransformOrigin: position?.startsWith('top-')\n\t\t\t\t\t\t? 'center top'\n\t\t\t\t\t\t: 'center bottom',\n\t\t\t\t\tzIndex,\n\t\t\t\t\ttransition: isSwiping\n\t\t\t\t\t\t? `transform 0s linear, opacity ${transitionDuration} ${transitionTimingFunction}`\n\t\t\t\t\t\t: `transform ${transitionDuration} ${transitionTimingFunction}, opacity ${transitionDuration} ${transitionTimingFunction}`,\n\t\t\t\t\t...transformStyle,\n\t\t\t\t}}\n\t\t\t\trole={stackHidden ? undefined : liveRole}\n\t\t\t\taria-live={stackHidden ? undefined : livePoliteness}\n\t\t\t\taria-atomic={stackHidden ? undefined : 'true'}\n\t\t\t\taria-describedby={stackHidden ? undefined : descriptionId}\n\t\t\t\taria-hidden={stackHidden ? true : undefined}\n\t\t\t\ttabIndex={-1}\n\t\t\t\tonTransitionEnd={handleTransitionEnd}\n\t\t\t\tdata-toast-id={id}\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\trole=\"alert\"\n\t\t\t\t\tclassName={cn(swipeCursorClass)}\n\t\t\t\t\tonPointerDown={handlePointerDown}\n\t\t\t\t\tonPointerMove={handlePointerMove}\n\t\t\t\t\tonPointerUp={handlePointerUp}\n\t\t\t\t\tonPointerCancel={handlePointerCancel}\n\t\t\t\t\tonMouseEnter={() => {\n\t\t\t\t\t\tsetIsItemHovered(true);\n\t\t\t\t\t\tonGroupHoverEnter?.();\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseLeave={() => setIsItemHovered(false)}\n\t\t\t\t\tonFocusCapture={() => setIsItemHovered(true)}\n\t\t\t\t\tonBlurCapture={(e) => {\n\t\t\t\t\t\tconst current = toastRef.current;\n\t\t\t\t\t\tconst next = e.relatedTarget as Node | null;\n\t\t\t\t\t\tif (!current || !next || !current.contains(next)) {\n\t\t\t\t\t\t\tsetIsItemHovered(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<div className={cn(toastContentVariants({ variant }))}>\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\tonClick={handleClose}\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t'absolute top-2 right-2 cursor-pointer rounded-sm p-1 text-foreground/45 hover:bg-popover-muted hover:text-foreground/70 transition-[background-color,color,box-shadow] ease-out-quad duration-100 focus-visible:ring-1 focus-visible:ring-ring/50 focus-visible:outline-none',\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\taria-label=\"Close toast\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Icons.X aria-hidden=\"true\" className=\"h-4 w-4\" />\n\t\t\t\t\t\t</button>\n\n\t\t\t\t\t\t<div className=\"p-4 pr-8\">\n\t\t\t\t\t\t\t{title && (\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tid={titleId}\n\t\t\t\t\t\t\t\t\tclassName=\"mb-1 text-sm leading-none font-medium select-none\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{title}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t{description && (\n\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\tid={descriptionId}\n\t\t\t\t\t\t\t\t\tclassName=\"text-sm leading-snug text-foreground/70 text-balance select-none\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{description}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t{action && (\n\t\t\t\t\t\t\t\t<div className=\"mt-3\">\n\t\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\t\t\taction.onClick();\n\t\t\t\t\t\t\t\t\t\t\thandleClose();\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tclassName=\"relative inline-flex cursor-pointer items-center justify-center rounded-md px-3 py-1.5 text-sm font-medium bg-linear-to-b from-gradient-from to-gradient-to hover:contrast-90 transition-[background-color,color,box-shadow,filter] ease-out-quad duration-100 shadow-[inset_0_1px_0_0_rgb(255_255_255/.32),0px_1px_1px_-0.5px_rgba(9,9,11,0.05),0px_3px_3px_-1.5px_rgba(9,9,11,0.05),0px_6px_6px_-3px_rgba(9,9,11,0.05)] dark:shadow-[inset_0_1px_0_0_rgb(255_255_255/.12),0px_1px_1px_-0.5px_rgba(9,9,11,0.05),0px_3px_3px_-1.5px_rgba(9,9,11,0.05),0px_6px_6px_-3px_rgba(9,9,11,0.05)] text-card-muted dark:text-foreground focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:ring-offset-ring-offset/50 focus-visible:outline-none focus-visible:ring-ring/50\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t{action.label}\n\t\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t},\n\t(prevProps, nextProps) => {\n\t\treturn (\n\t\t\tprevProps.toast.id === nextProps.toast.id &&\n\t\t\tprevProps.toast.index === nextProps.toast.index &&\n\t\t\tprevProps.toast.shouldClose === nextProps.toast.shouldClose &&\n\t\t\tprevProps.toast.renderIndex === nextProps.toast.renderIndex &&\n\t\t\tprevProps.toast.total === nextProps.toast.total &&\n\t\t\tprevProps.isGroupHovered === nextProps.isGroupHovered &&\n\t\t\tprevProps.expandedOffset === nextProps.expandedOffset &&\n\t\t\tprevProps.expandedGap === nextProps.expandedGap &&\n\t\t\tprevProps.collapsedOffset === nextProps.collapsedOffset &&\n\t\t\tprevProps.hiddenCollapsedOffset === nextProps.hiddenCollapsedOffset\n\t\t);\n\t},\n);\n\nToastItem.displayName = 'ToastItem';\n\nconst ToastManager: React.FC<{\n\ttoasts: ToastData[];\n\tonRemove: (id: string) => void;\n\texpandedGap?: number;\n}> = React.memo(\n\t({ toasts, onRemove, expandedGap = ANIMATION_CONFIG.EXPANDED_GAP }) => {\n\t\tconst [heights, setHeights] = useState<Record<string, number>>({});\n\t\tconst [hovered, setHovered] = useState<Record<ToastPosition, boolean>>({\n\t\t\t'top-left': false,\n\t\t\t'top-center': false,\n\t\t\t'top-right': false,\n\t\t\t'bottom-left': false,\n\t\t\t'bottom-center': false,\n\t\t\t'bottom-right': false,\n\t\t});\n\t\tconst previousStackIndexRef = useRef<Record<string, number>>({});\n\t\tconst previousCollapsedOffsetsRef = useRef<Record<string, number>>({});\n\t\tconst previousExpandedOffsetsRef = useRef<Record<string, number>>({});\n\n\t\tconst toastsByPosition = useMemo(() => {\n\t\t\tconst grouped = toasts.reduce(\n\t\t\t\t(acc, toast) => {\n\t\t\t\t\tconst pos = toast.position || 'bottom-center';\n\t\t\t\t\tif (!acc[pos]) acc[pos] = [];\n\t\t\t\t\tacc[pos].push(toast);\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{} as Record<ToastPosition, ToastData[]>,\n\t\t\t);\n\n\t\t\tconst nextStackIndices: Record<string, number> = {};\n\n\t\t\tObject.keys(grouped).forEach((position) => {\n\t\t\t\tconst positionKey = position as ToastPosition;\n\t\t\t\tconst list = grouped[positionKey];\n\t\t\t\tconst activeToasts = list.filter(\n\t\t\t\t\t(toast) => !toast.isLeaving && !toast.shouldClose,\n\t\t\t\t);\n\t\t\t\tconst activeIndexMap = new Map<string, number>();\n\n\t\t\t\tactiveToasts.forEach((toast, activeIndex) => {\n\t\t\t\t\tactiveIndexMap.set(toast.id, activeIndex);\n\t\t\t\t});\n\n\t\t\t\tgrouped[positionKey] = list.map((toast, orderIndex) => {\n\t\t\t\t\tlet stackIndex =\n\t\t\t\t\t\tactiveIndexMap.get(toast.id) ??\n\t\t\t\t\t\tpreviousStackIndexRef.current[toast.id];\n\n\t\t\t\t\tif (stackIndex == null || Number.isNaN(stackIndex)) {\n\t\t\t\t\t\tstackIndex = orderIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\tnextStackIndices[toast.id] = stackIndex;\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...toast,\n\t\t\t\t\t\tindex: stackIndex,\n\t\t\t\t\t\trenderIndex: orderIndex,\n\t\t\t\t\t\ttotal: list.length,\n\t\t\t\t\t};\n\t\t\t\t}) as PositionedToast[];\n\t\t\t});\n\n\t\t\tpreviousStackIndexRef.current = nextStackIndices;\n\n\t\t\treturn grouped as Record<ToastPosition, PositionedToast[]>;\n\t\t}, [toasts]);\n\n\t\tuseEffect(() => {\n\t\t\tsetHovered((prev) => {\n\t\t\t\tlet changed = false;\n\t\t\t\tconst next = { ...prev };\n\t\t\t\tconst positions = Object.keys(prev) as ToastPosition[];\n\t\t\t\tfor (const pos of positions) {\n\t\t\t\t\tconst hasToast = (toastsByPosition[pos]?.length ?? 0) > 0;\n\t\t\t\t\tif (!hasToast && next[pos]) {\n\t\t\t\t\t\tnext[pos] = false;\n\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn changed ? next : prev;\n\t\t\t});\n\t\t}, [toastsByPosition]);\n\n\t\tconst positionEntries = useMemo(\n\t\t\t() => Object.entries(toastsByPosition),\n\t\t\t[toastsByPosition],\n\t\t);\n\n\t\tconst collapsedOffsetData = useMemo(() => {\n\t\t\tconst byPosition: Record<ToastPosition, number[]> = {\n\t\t\t\t'top-left': [],\n\t\t\t\t'top-center': [],\n\t\t\t\t'top-right': [],\n\t\t\t\t'bottom-left': [],\n\t\t\t\t'bottom-center': [],\n\t\t\t\t'bottom-right': [],\n\t\t\t};\n\t\t\tconst byId: Record<string, number> = {};\n\n\t\t\tfor (const [pos, group] of positionEntries as [\n\t\t\t\tToastPosition,\n\t\t\t\tPositionedToast[],\n\t\t\t][]) {\n\t\t\t\tconst isTopPosition = pos.startsWith('top-');\n\t\t\t\tconst activeToasts = group.filter((toast) => !toast.shouldClose);\n\t\t\t\tconst offsetsForActive: number[] = [];\n\n\t\t\t\tfor (let i = 0; i < activeToasts.length; i++) {\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\toffsetsForActive.push(0);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst prevToast = activeToasts[i - 1];\n\t\t\t\t\tconst currentToast = activeToasts[i];\n\t\t\t\t\tconst prevOffset = offsetsForActive[i - 1] ?? 0;\n\t\t\t\t\tif (!prevToast || !currentToast) {\n\t\t\t\t\t\toffsetsForActive.push(prevOffset);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst prevHeight = heights[prevToast.id];\n\t\t\t\t\tconst currentHeight = heights[currentToast.id];\n\t\t\t\t\tconst fallbackOffset =\n\t\t\t\t\t\tprevOffset +\n\t\t\t\t\t\t(isTopPosition ? 1 : -1) * ANIMATION_CONFIG.STACK_OFFSET;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tprevHeight == null ||\n\t\t\t\t\t\tcurrentHeight == null ||\n\t\t\t\t\t\tNumber.isNaN(prevHeight) ||\n\t\t\t\t\t\tNumber.isNaN(currentHeight)\n\t\t\t\t\t) {\n\t\t\t\t\t\toffsetsForActive.push(fallbackOffset);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isTopPosition) {\n\t\t\t\t\t\toffsetsForActive.push(\n\t\t\t\t\t\t\tprevOffset +\n\t\t\t\t\t\t\t\t(prevHeight - currentHeight + ANIMATION_CONFIG.STACK_OFFSET),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffsetsForActive.push(\n\t\t\t\t\t\t\tprevOffset +\n\t\t\t\t\t\t\t\t(currentHeight - prevHeight - ANIMATION_CONFIG.STACK_OFFSET),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < activeToasts.length; i++) {\n\t\t\t\t\tconst toast = activeToasts[i];\n\t\t\t\t\tif (!toast) continue;\n\t\t\t\t\tbyId[toast.id] = offsetsForActive[i] ?? 0;\n\t\t\t\t}\n\n\t\t\t\tfor (const toast of group) {\n\t\t\t\t\tif (byId[toast.id] != null) continue;\n\n\t\t\t\t\tconst previousOffset = previousCollapsedOffsetsRef.current[toast.id];\n\t\t\t\t\tif (typeof previousOffset === 'number') {\n\t\t\t\t\t\tbyId[toast.id] = previousOffset;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst defaultOffset = isTopPosition\n\t\t\t\t\t\t? toast.index * ANIMATION_CONFIG.STACK_OFFSET\n\t\t\t\t\t\t: -(toast.index * ANIMATION_CONFIG.STACK_OFFSET);\n\t\t\t\t\tbyId[toast.id] = defaultOffset;\n\t\t\t\t}\n\n\t\t\t\tbyPosition[pos] = group.map((toast) => byId[toast.id] ?? 0);\n\t\t\t}\n\n\t\t\treturn { byPosition, byId };\n\t\t}, [positionEntries, heights]);\n\n\t\tconst expandedOffsetData = useMemo(() => {\n\t\t\tconst byPosition: Record<ToastPosition, number[]> = {\n\t\t\t\t'top-left': [],\n\t\t\t\t'top-center': [],\n\t\t\t\t'top-right': [],\n\t\t\t\t'bottom-left': [],\n\t\t\t\t'bottom-center': [],\n\t\t\t\t'bottom-right': [],\n\t\t\t};\n\t\t\tconst byId: Record<string, number> = {};\n\n\t\t\tfor (const [pos, group] of positionEntries as [\n\t\t\t\tToastPosition,\n\t\t\t\tPositionedToast[],\n\t\t\t][]) {\n\t\t\t\tconst offsets: number[] = [];\n\t\t\t\tconst activeToasts = group.filter((toast) => !toast.shouldClose);\n\t\t\t\tlet acc = 0;\n\n\t\t\t\tfor (let i = 0; i < activeToasts.length; i++) {\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\toffsets.push(0);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst prevToast = activeToasts[i - 1];\n\t\t\t\t\tconst prevHeight = prevToast ? (heights[prevToast.id] ?? 0) : 0;\n\t\t\t\t\tacc += prevHeight + expandedGap;\n\t\t\t\t\toffsets.push(acc);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < activeToasts.length; i++) {\n\t\t\t\t\tconst toast = activeToasts[i];\n\t\t\t\t\tif (!toast) continue;\n\t\t\t\t\tbyId[toast.id] = offsets[i] ?? 0;\n\t\t\t\t}\n\n\t\t\t\tfor (const toast of group) {\n\t\t\t\t\tif (byId[toast.id] != null) continue;\n\n\t\t\t\t\tconst previousOffset = previousExpandedOffsetsRef.current[toast.id];\n\t\t\t\t\tif (typeof previousOffset === 'number') {\n\t\t\t\t\t\tbyId[toast.id] = previousOffset;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet fallback = 0;\n\t\t\t\t\tfor (const candidate of group) {\n\t\t\t\t\t\tif (candidate.id === toast.id) break;\n\t\t\t\t\t\tconst height = heights[candidate.id] ?? 0;\n\t\t\t\t\t\tfallback += height + expandedGap;\n\t\t\t\t\t}\n\t\t\t\t\tbyId[toast.id] = fallback;\n\t\t\t\t}\n\n\t\t\t\tbyPosition[pos] = group.map((toast) => byId[toast.id] ?? 0);\n\t\t\t}\n\n\t\t\treturn { byPosition, byId };\n\t\t}, [positionEntries, heights, expandedGap]);\n\n\t\tuseEffect(() => {\n\t\t\tpreviousCollapsedOffsetsRef.current = collapsedOffsetData.byId;\n\t\t}, [collapsedOffsetData]);\n\n\t\tuseEffect(() => {\n\t\t\tpreviousExpandedOffsetsRef.current = expandedOffsetData.byId;\n\t\t}, [expandedOffsetData]);\n\n\t\tconst collapsedOffsetsByPosition = collapsedOffsetData.byPosition;\n\t\tconst expandedOffsetsByPosition = expandedOffsetData.byPosition;\n\n\t\tuseEffect(() => {\n\t\t\tif (positionEntries.length === 0) return;\n\n\t\t\tconst handler = (e: MouseEvent) => {\n\t\t\t\tconst { clientX: x, clientY: y } = e;\n\t\t\t\tconst next: Record<ToastPosition, boolean> = { ...hovered } as Record<\n\t\t\t\t\tToastPosition,\n\t\t\t\t\tboolean\n\t\t\t\t>;\n\t\t\t\tfor (const [pos, group] of positionEntries as [\n\t\t\t\t\tToastPosition,\n\t\t\t\t\tPositionedToast[],\n\t\t\t\t][]) {\n\t\t\t\t\tlet top = Number.POSITIVE_INFINITY;\n\t\t\t\t\tlet left = Number.POSITIVE_INFINITY;\n\t\t\t\t\tlet right = Number.NEGATIVE_INFINITY;\n\t\t\t\t\tlet bottom = Number.NEGATIVE_INFINITY;\n\t\t\t\t\tlet any = false;\n\t\t\t\t\tfor (const t of group) {\n\t\t\t\t\t\tif (t.index >= ANIMATION_CONFIG.MAX_VISIBLE_TOASTS) continue;\n\t\t\t\t\t\tconst el = document.querySelector(\n\t\t\t\t\t\t\t`[data-toast-id=\"${t.id}\"]`,\n\t\t\t\t\t\t) as HTMLElement | null;\n\t\t\t\t\t\tif (!el) continue;\n\t\t\t\t\t\tconst r = el.getBoundingClientRect();\n\t\t\t\t\t\ttop = Math.min(top, r.top);\n\t\t\t\t\t\tleft = Math.min(left, r.left);\n\t\t\t\t\t\tright = Math.max(right, r.right);\n\t\t\t\t\t\tbottom = Math.max(bottom, r.bottom);\n\t\t\t\t\t\tany = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!any) {\n\t\t\t\t\t\tnext[pos] = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst inside = x >= left && x <= right && y >= top && y <= bottom;\n\t\t\t\t\tnext[pos] = inside;\n\t\t\t\t}\n\t\t\t\tconst changed = Object.keys(next as Record<string, boolean>).some(\n\t\t\t\t\t(k) =>\n\t\t\t\t\t\t(next as Record<string, boolean>)[k] !==\n\t\t\t\t\t\t(hovered as Record<string, boolean>)[k],\n\t\t\t\t);\n\t\t\t\tif (changed) setHovered(next);\n\t\t\t};\n\n\t\t\tdocument.addEventListener('mousemove', handler);\n\t\t\treturn () => document.removeEventListener('mousemove', handler);\n\t\t}, [hovered, positionEntries]);\n\n\t\tuseEffect(() => {\n\t\t\tif (positionEntries.length === 0) return;\n\n\t\t\tconst handleKeyDown = (e: KeyboardEvent) => {\n\t\t\t\tfor (const [, group] of positionEntries) {\n\t\t\t\t\tconst latest = group?.[0];\n\t\t\t\t\tif (!latest) continue;\n\n\t\t\t\t\tconst container = document.querySelector(\n\t\t\t\t\t\t`[data-toast-id=\"${latest.id}\"]`,\n\t\t\t\t\t) as HTMLElement | null;\n\t\t\t\t\tif (!container) continue;\n\n\t\t\t\t\tif (e.key === 'Escape') {\n\t\t\t\t\t\tconst active = document.activeElement as HTMLElement | null;\n\t\t\t\t\t\tif (active && container.contains(active)) {\n\t\t\t\t\t\t\tconst closeBtn = container.querySelector(\n\t\t\t\t\t\t\t\t'[aria-label=\"Close toast\"]',\n\t\t\t\t\t\t\t) as HTMLButtonElement | null;\n\t\t\t\t\t\t\tif (closeBtn) {\n\t\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t\t\tcloseBtn.click();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdocument.addEventListener('keydown', handleKeyDown);\n\t\t\treturn () => document.removeEventListener('keydown', handleKeyDown);\n\t\t}, [positionEntries]);\n\n\t\tif (toasts.length === 0) return null;\n\n\t\treturn (\n\t\t\t<div className=\"pointer-events-none fixed inset-0 z-50\">\n\t\t\t\t{positionEntries.map(([position, positionToasts]) => {\n\t\t\t\t\tconst pos = position as ToastPosition;\n\t\t\t\t\tconst expandedOffsets = expandedOffsetsByPosition[pos];\n\t\t\t\t\tconst collapsedOffsets = collapsedOffsetsByPosition[pos];\n\t\t\t\t\tconst isHovered = hovered[pos];\n\t\t\t\t\tconst activeToasts = positionToasts.filter(\n\t\t\t\t\t\t(toast) => !toast.shouldClose,\n\t\t\t\t\t);\n\t\t\t\t\tconst visibleStackLimit = Math.max(\n\t\t\t\t\t\tANIMATION_CONFIG.MAX_VISIBLE_TOASTS - 1,\n\t\t\t\t\t\t0,\n\t\t\t\t\t);\n\t\t\t\t\tconst maxVisibleStackIndex = Math.min(\n\t\t\t\t\t\tMath.max(activeToasts.length - 1, 0),\n\t\t\t\t\t\tvisibleStackLimit,\n\t\t\t\t\t);\n\t\t\t\t\tconst lastVisibleToastId = activeToasts[maxVisibleStackIndex]?.id;\n\t\t\t\t\tconst lastVisibleRenderIndex =\n\t\t\t\t\t\tlastVisibleToastId != null\n\t\t\t\t\t\t\t? positionToasts.findIndex(\n\t\t\t\t\t\t\t\t\t(candidate) => candidate.id === lastVisibleToastId,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: -1;\n\t\t\t\t\tconst sharedHiddenCollapsedOffset =\n\t\t\t\t\t\tlastVisibleRenderIndex >= 0\n\t\t\t\t\t\t\t? collapsedOffsets?.[lastVisibleRenderIndex]\n\t\t\t\t\t\t\t: undefined;\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<React.Fragment key={position}>\n\t\t\t\t\t\t\t{positionToasts.map((toast, idx) => {\n\t\t\t\t\t\t\t\tconst toastIsHidden =\n\t\t\t\t\t\t\t\t\ttoast.index >= ANIMATION_CONFIG.MAX_VISIBLE_TOASTS;\n\t\t\t\t\t\t\t\tconst hiddenCollapsedOffset = toastIsHidden\n\t\t\t\t\t\t\t\t\t? (sharedHiddenCollapsedOffset ?? collapsedOffsets?.[idx])\n\t\t\t\t\t\t\t\t\t: collapsedOffsets?.[idx];\n\t\t\t\t\t\t\t\tconst collapsedOffsetValue = collapsedOffsets?.[idx];\n\t\t\t\t\t\t\t\tconst itemProps: ToastItemProps = {\n\t\t\t\t\t\t\t\t\ttoast,\n\t\t\t\t\t\t\t\t\tonRemove,\n\t\t\t\t\t\t\t\t\tisGroupHovered: isHovered,\n\t\t\t\t\t\t\t\t\texpandedOffset: expandedOffsets?.[idx] ?? 0,\n\t\t\t\t\t\t\t\t\texpandedGap,\n\t\t\t\t\t\t\t\t\tonHeightChange: (id, h) =>\n\t\t\t\t\t\t\t\t\t\tsetHeights((prev) =>\n\t\t\t\t\t\t\t\t\t\t\tprev[id] === h ? prev : { ...prev, [id]: h },\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tonGroupHoverEnter: () =>\n\t\t\t\t\t\t\t\t\t\tsetHovered((prev) => ({ ...prev, [pos]: true })),\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (collapsedOffsetValue !== undefined) {\n\t\t\t\t\t\t\t\t\titemProps.collapsedOffset = collapsedOffsetValue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (hiddenCollapsedOffset !== undefined) {\n\t\t\t\t\t\t\t\t\titemProps.hiddenCollapsedOffset = hiddenCollapsedOffset;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn <ToastItem key={toast.id} {...itemProps} />;\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</React.Fragment>\n\t\t\t\t\t);\n\t\t\t\t})}\n\t\t\t</div>\n\t\t);\n\t},\n);\n\nToastManager.displayName = 'ToastManager';\n\nexport const Toaster: React.FC<{ expandedGap?: number }> = ({\n\texpandedGap,\n}) => {\n\tconst [toasts, setToasts] = useState<ToastData[]>([]);\n\tconst [instanceId] = useState(() =>\n\t\ttoasterInstanceManager.registerInstance(),\n\t);\n\n\tuseEffect(() => {\n\t\tconst unsubscribe = toastState.subscribe(setToasts);\n\t\treturn () => {\n\t\t\tunsubscribe();\n\t\t\ttoasterInstanceManager.unregisterInstance(instanceId);\n\t\t};\n\t}, [instanceId]);\n\n\tconst handleRemove = useCallback((id: string) => {\n\t\ttoastState.remove(id);\n\t}, []);\n\n\tif (!toasterInstanceManager.isActiveInstance(instanceId)) {\n\t\treturn null;\n\t}\n\n\tconst managerProps = expandedGap === undefined ? {} : { expandedGap };\n\treturn (\n\t\t<ToastManager toasts={toasts} onRemove={handleRemove} {...managerProps} />\n\t);\n};\n",
      "type": "registry:component"
    }
  ]
}