{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "line-chart",
  "type": "registry:component",
  "title": "Line Chart",
  "description": "Track evolving metrics and dynamic changes using clear, continuous line plots",
  "dependencies": [
    "clsx",
    "d3-shape",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/line-chart.tsx",
      "content": "'use client';\n\nimport {\n\tcurveLinear,\n\tcurveMonotoneX,\n\tcurveNatural,\n\tcurveStep,\n\tline,\n} from 'd3-shape';\nimport * as React from 'react';\nimport { cn } from '@/lib/utils';\n\ntype ChartDatum = Record<string, unknown>;\n\nconst DEFAULT_HEIGHT = 220;\nconst DEFAULT_COLORS = [\n\t'var(--color-chart-1)',\n\t'var(--color-chart-2)',\n\t'var(--color-chart-3)',\n\t'var(--color-chart-4)',\n\t'var(--color-chart-5)',\n] as const;\n\nconst CHART_PADDING = { top: 16, right: 16, bottom: 24, left: 16 } as const;\nconst Y_AXIS_CHART_GAP = 8;\nconst FALLBACK_CHART_DIMENSIONS = { width: 360, height: 240 } as const;\nconst DEFAULT_Y_TICK_TARGET = 5;\n\nconst CURVE_FACTORIES = {\n\tlinear: curveLinear,\n\tmonotone: curveMonotoneX,\n\tnatural: curveNatural,\n\tstep: curveStep,\n} as const;\n\nexport type LineChartCurve = keyof typeof CURVE_FACTORIES;\n\nexport type LineChartPoint<TData extends ChartDatum = ChartDatum> = {\n\tid: string;\n\tseriesId: string;\n\tseriesIndex: number;\n\tdatum: TData;\n\tindex: number;\n\tx: number;\n\txRaw: unknown;\n\ty: number;\n\tlabel: string;\n\tvalue: number;\n};\n\nexport interface LineChartAdditionalSeries<\n\tTData extends ChartDatum = ChartDatum,\n> {\n\tid?: string;\n\tdata?: TData[];\n\txKey?: Extract<keyof TData, string>;\n\tyKey: Extract<keyof TData, string>;\n\tnameKey?: Extract<keyof TData, string>;\n\tcolor?: string;\n\tseriesLabel?: string;\n\tsortPoints?: boolean | ((a: TData, b: TData) => number);\n\tyFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n\tvalueFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n}\n\ninterface LineChartSeriesState<TData extends ChartDatum> {\n\tid: string;\n\tseriesIndex: number;\n\tpoints: LineChartPoint<TData>[];\n\ttotal: number;\n\tseriesLabel: string;\n\tvalueLabel: string;\n\tcolor: string;\n\tformatY: (point: LineChartPoint<TData>) => React.ReactNode;\n}\n\ninterface LineChartSeriesComputation<TData extends ChartDatum>\n\textends Omit<LineChartSeriesState<TData>, 'formatY'> {\n\tyFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n\tvalueFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n}\n\ninterface LineChartContextValue<TData extends ChartDatum> {\n\tseries: LineChartSeriesState<TData>[];\n\tpoints: LineChartPoint<TData>[];\n\ttotal: number;\n\tseriesLabel: string;\n\tcolor: string;\n\txDomain: [number, number];\n\tyDomain: [number, number];\n\tformatX: (point: LineChartPoint<TData>) => React.ReactNode;\n\tformatY: (point: LineChartPoint<TData>) => React.ReactNode;\n\tformatYForSeries: (\n\t\tseriesId: string,\n\t\tpoint: LineChartPoint<TData>,\n\t) => React.ReactNode;\n\tvalueLabel: string;\n\txLabel: string;\n\tactivePointId: string | null;\n\tsetActivePointId: (id: string | null) => void;\n\tactivePointX: number | null;\n\tsetActivePointX: (value: number | null) => void;\n}\n\nconst LineChartContext =\n\tReact.createContext<LineChartContextValue<ChartDatum> | null>(null);\n\nexport function useLineChartContext<TData extends ChartDatum = ChartDatum>() {\n\tconst context = React.useContext(\n\t\tLineChartContext,\n\t) as LineChartContextValue<TData> | null;\n\n\tif (!context) {\n\t\tthrow new Error(\n\t\t\t'useLineChartContext must be used within an <LineChart> component.',\n\t\t);\n\t}\n\n\treturn context;\n}\n\nfunction getNumericValue(input: unknown): number | null {\n\tif (typeof input === 'number' && Number.isFinite(input)) {\n\t\treturn input;\n\t}\n\tif (typeof input === 'string') {\n\t\tconst parsed = Number.parseFloat(input);\n\t\tif (Number.isFinite(parsed)) {\n\t\t\treturn parsed;\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction getTemporalValue(input: unknown): number | null {\n\tif (input instanceof Date && Number.isFinite(input.valueOf())) {\n\t\treturn input.getTime();\n\t}\n\tif (typeof input === 'number' && Number.isFinite(input)) {\n\t\treturn input;\n\t}\n\tif (typeof input === 'string') {\n\t\tconst numeric = Number.parseFloat(input);\n\t\tif (Number.isFinite(numeric)) {\n\t\t\treturn numeric;\n\t\t}\n\t\tconst parsedDate = new Date(input);\n\t\tif (!Number.isNaN(parsedDate.valueOf())) {\n\t\t\treturn parsedDate.getTime();\n\t\t}\n\t}\n\treturn null;\n}\n\nfunction toKeyLabel(key: string): string {\n\tconst words = key\n\t\t.replace(/([a-z0-9])([A-Z])/g, '$1 $2')\n\t\t.replace(/[_-]+/g, ' ')\n\t\t.split(' ')\n\t\t.map((part) => part.trim())\n\t\t.filter(Boolean)\n\t\t.map((part) => part.slice(0, 1).toUpperCase() + part.slice(1));\n\treturn words.length ? words.join(' ') : key;\n}\n\nfunction resolveColor(color: string | undefined, index: number): string {\n\tif (color && color.trim().length > 0) return color;\n\tconst fallbackIndex =\n\t\tDEFAULT_COLORS.length > 0 ? index % DEFAULT_COLORS.length : 0;\n\tconst fallback = DEFAULT_COLORS[fallbackIndex];\n\tif (!fallback) {\n\t\tthrow new Error('Unable to resolve fallback color for LineChart.');\n\t}\n\treturn fallback;\n}\n\nfunction createLinearScale(\n\tdomain: [number, number],\n\trange: [number, number],\n): (value: number) => number {\n\tconst [d0, d1] = domain;\n\tconst [r0, r1] = range;\n\tif (!Number.isFinite(d0) || !Number.isFinite(d1)) {\n\t\treturn () => r0;\n\t}\n\tif (d0 === d1) {\n\t\treturn () => (r0 + r1) / 2;\n\t}\n\tconst scale = (value: number) => {\n\t\tconst ratio = (value - d0) / (d1 - d0);\n\t\treturn r0 + ratio * (r1 - r0);\n\t};\n\treturn scale;\n}\n\nfunction clamp(value: number, min: number, max: number) {\n\treturn Math.min(Math.max(value, min), max);\n}\n\nfunction toPlainText(value: React.ReactNode, fallback: string): string {\n\tif (typeof value === 'string') return value;\n\tif (typeof value === 'number' && Number.isFinite(value)) {\n\t\treturn value.toString();\n\t}\n\treturn fallback;\n}\n\nfunction getPointLabelText(point: LineChartPoint) {\n\treturn point.label ?? String(point.xRaw ?? '');\n}\n\nfunction getPointValueText(point: LineChartPoint) {\n\tif (Number.isFinite(point.value)) {\n\t\treturn point.value.toLocaleString();\n\t}\n\treturn String(point.value);\n}\n\nfunction niceNumber(range: number, round: boolean) {\n\tif (range === 0) return 0;\n\tconst exponent = Math.floor(Math.log10(Math.abs(range)));\n\tconst fraction = Math.abs(range) / 10 ** exponent;\n\tlet niceFraction: number;\n\n\tif (round) {\n\t\tif (fraction < 1.5) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction < 3) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction < 7) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\t} else {\n\t\tif (fraction <= 1) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\t}\n\n\treturn Math.sign(range) * niceFraction * 10 ** exponent;\n}\n\nfunction generateLinearTicks(\n\t[min, max]: [number, number],\n\tdesiredCount: number,\n) {\n\tconst safeCount = Number.isFinite(desiredCount)\n\t\t? Math.max(desiredCount, 2)\n\t\t: 2;\n\tif (!Number.isFinite(min) || !Number.isFinite(max)) return [];\n\tif (min === max) return [min];\n\n\tconst range = max - min;\n\tconst niceRange = niceNumber(range, false);\n\tconst step = niceNumber(niceRange / (safeCount - 1), true);\n\tconst niceMin = Math.floor(min / step) * step;\n\tconst niceMax = Math.ceil(max / step) * step;\n\n\tconst ticks: number[] = [];\n\tfor (let value = niceMin; value <= niceMax + step / 2; value += step) {\n\t\tconst rounded = Number.parseFloat(value.toFixed(12));\n\t\tticks.push(rounded);\n\t}\n\tconst domainWithPadding = step * 0.5;\n\tconst withinDomain = ticks.filter(\n\t\t(value) =>\n\t\t\tvalue >= min - domainWithPadding && value <= max + domainWithPadding,\n\t);\n\treturn withinDomain.length ? withinDomain : [min, max];\n}\n\nfunction alignDomainToNiceValues(\n\t[min, max]: [number, number],\n\ttargetCount: number = DEFAULT_Y_TICK_TARGET,\n): [number, number] {\n\tif (!Number.isFinite(min) || !Number.isFinite(max)) {\n\t\treturn [min, max];\n\t}\n\n\tif (min === max) {\n\t\tconst padding = Math.max(Math.abs(min) * 0.5, 1);\n\t\treturn [min - padding, max + padding];\n\t}\n\n\tconst safeCount = Number.isFinite(targetCount)\n\t\t? Math.max(Math.floor(targetCount), 2)\n\t\t: DEFAULT_Y_TICK_TARGET;\n\tconst range = max - min;\n\tconst rawStep = range / (safeCount - 1);\n\tconst step = niceNumber(rawStep, true);\n\n\tif (!Number.isFinite(step) || step <= 0) {\n\t\treturn [min, max];\n\t}\n\n\tlet niceMin = Math.floor(min / step) * step;\n\tlet niceMax = Math.ceil(max / step) * step;\n\n\tconst minimumPadding = step * 0.1;\n\tconst paddingAbove = niceMax - max;\n\tconst paddingBelow = min - niceMin;\n\n\tif (min >= 0) {\n\t\tniceMin = 0;\n\t} else if (paddingBelow < minimumPadding) {\n\t\tniceMin -= step;\n\t}\n\tif (max <= 0) {\n\t\tniceMax = 0;\n\t} else if (paddingAbove < minimumPadding) {\n\t\tniceMax += step;\n\t}\n\n\tif (niceMin === niceMax) {\n\t\treturn [niceMin - step, niceMax + step];\n\t}\n\n\treturn [niceMin, niceMax];\n}\n\nfunction selectPointsForTicks(points: LineChartPoint[], desiredCount: number) {\n\tif (!points.length) return [];\n\tconst uniquePoints: LineChartPoint[] = [];\n\tconst seen = new Set<number>();\n\tfor (const point of points) {\n\t\tif (seen.has(point.x)) continue;\n\t\tseen.add(point.x);\n\t\tuniquePoints.push(point);\n\t}\n\tconst safeCount = Math.max(2, Math.min(desiredCount, uniquePoints.length));\n\tif (uniquePoints.length <= safeCount) {\n\t\treturn uniquePoints;\n\t}\n\n\tconst lastIndex = uniquePoints.length - 1;\n\tconst step = lastIndex / (safeCount - 1);\n\tconst selectedIndices = new Set<number>();\n\n\tfor (let i = 0; i < safeCount; i++) {\n\t\tconst rawIndex = Math.round(i * step);\n\t\tconst clampedIndex = clamp(rawIndex, 0, lastIndex);\n\t\tselectedIndices.add(clampedIndex);\n\t}\n\n\tselectedIndices.add(0);\n\tselectedIndices.add(lastIndex);\n\n\tconst sortedIndices = Array.from(selectedIndices).sort((a, b) => a - b);\n\n\tif (sortedIndices.length < safeCount) {\n\t\tfor (\n\t\t\tlet index = 0;\n\t\t\tindex <= lastIndex && sortedIndices.length < safeCount;\n\t\t\tindex++\n\t\t) {\n\t\t\tif (!selectedIndices.has(index)) {\n\t\t\t\tsortedIndices.push(index);\n\t\t\t}\n\t\t}\n\t\tsortedIndices.sort((a, b) => a - b);\n\t}\n\n\treturn sortedIndices\n\t\t.map((index) => uniquePoints[index])\n\t\t.filter((p): p is NonNullable<typeof p> => p !== undefined);\n}\n\nexport interface LineChartProps<TData extends ChartDatum = ChartDatum>\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tdata: TData[];\n\txKey: Extract<keyof TData, string>;\n\tyKey: Extract<keyof TData, string>;\n\tnameKey?: Extract<keyof TData, string>;\n\tcolor?: string;\n\tseriesLabel?: string;\n\tsortPoints?: boolean | ((a: TData, b: TData) => number);\n\txFormatter?: (point: LineChartPoint<TData>) => React.ReactNode;\n\tyFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n\tvalueFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n\tadditionalSeries?: LineChartAdditionalSeries<TData>[];\n\tchildren?: React.ReactNode;\n}\n\nfunction LineChartRootInner<TData extends ChartDatum>(\n\t{\n\t\tdata,\n\t\txKey,\n\t\tyKey,\n\t\tnameKey,\n\t\tcolor,\n\t\tseriesLabel,\n\t\tsortPoints = true,\n\t\txFormatter,\n\t\tyFormatter,\n\t\tvalueFormatter,\n\t\tadditionalSeries = [],\n\t\tclassName,\n\t\tchildren,\n\t\t...rest\n\t}: LineChartProps<TData>,\n\tref: React.ForwardedRef<HTMLDivElement>,\n) {\n\tconst [activePointId, setActivePointId] = React.useState<string | null>(null);\n\tconst [activePointX, setActivePointX] = React.useState<number | null>(null);\n\n\tconst xLabel = React.useMemo(() => toKeyLabel(String(xKey)), [xKey]);\n\n\tconst { seriesCollection, xDomain, yDomain } = React.useMemo(() => {\n\t\tconst buildSeries = (source: {\n\t\t\tid: string;\n\t\t\tseriesIndex: number;\n\t\t\tdata: TData[];\n\t\t\txKey: Extract<keyof TData, string>;\n\t\t\tyKey: Extract<keyof TData, string>;\n\t\t\tnameKey?: Extract<keyof TData, string>;\n\t\t\tcolor?: string;\n\t\t\tseriesLabel?: string;\n\t\t\tsortPoints: boolean | ((a: TData, b: TData) => number);\n\t\t\tyFormatter?: (\n\t\t\t\tpoint: LineChartPoint<TData>,\n\t\t\t\tmeta: { total: number; domain: [number, number] },\n\t\t\t) => React.ReactNode;\n\t\t\tvalueFormatter?: (\n\t\t\t\tpoint: LineChartPoint<TData>,\n\t\t\t\tmeta: { total: number; domain: [number, number] },\n\t\t\t) => React.ReactNode;\n\t\t}): LineChartSeriesComputation<TData> => {\n\t\t\tconst resolvedXLabel = toKeyLabel(String(source.xKey));\n\t\t\tconst resolvedPoints = source.data\n\t\t\t\t.map<LineChartPoint<TData> | null>((datum, index) => {\n\t\t\t\t\tconst numericValue = getNumericValue(datum[source.yKey]);\n\t\t\t\t\tif (numericValue === null) return null;\n\t\t\t\t\tconst rawX = datum[source.xKey];\n\t\t\t\t\tconst temporal = getTemporalValue(rawX);\n\t\t\t\t\tconst resolvedX = temporal ?? index;\n\t\t\t\t\tconst label =\n\t\t\t\t\t\tsource.nameKey && datum[source.nameKey] != null\n\t\t\t\t\t\t\t? String(datum[source.nameKey])\n\t\t\t\t\t\t\t: typeof rawX === 'string' || typeof rawX === 'number'\n\t\t\t\t\t\t\t\t? String(rawX)\n\t\t\t\t\t\t\t\t: `${resolvedXLabel} ${index + 1}`;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: `${source.id}-${resolvedX}-${index}`,\n\t\t\t\t\t\tseriesId: source.id,\n\t\t\t\t\t\tseriesIndex: source.seriesIndex,\n\t\t\t\t\t\tdatum,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tx: resolvedX,\n\t\t\t\t\t\txRaw: rawX,\n\t\t\t\t\t\ty: numericValue,\n\t\t\t\t\t\tlabel,\n\t\t\t\t\t\tvalue: numericValue,\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t\t.filter((point): point is LineChartPoint<TData> => Boolean(point));\n\n\t\t\tconst sortedPoints = (() => {\n\t\t\t\tif (typeof source.sortPoints === 'function') {\n\t\t\t\t\tconst sortFn = source.sortPoints;\n\t\t\t\t\treturn [...resolvedPoints].sort((a, b) => sortFn(a.datum, b.datum));\n\t\t\t\t}\n\t\t\t\tif (source.sortPoints) {\n\t\t\t\t\treturn [...resolvedPoints].sort((a, b) => a.x - b.x);\n\t\t\t\t}\n\t\t\t\treturn resolvedPoints;\n\t\t\t})();\n\n\t\t\tconst totalValue = sortedPoints.reduce(\n\t\t\t\t(sum, point) => sum + (Number.isFinite(point.value) ? point.value : 0),\n\t\t\t\t0,\n\t\t\t);\n\n\t\t\tconst resolvedSeriesLabel = source.seriesLabel?.trim().length\n\t\t\t\t? source.seriesLabel\n\t\t\t\t: source.nameKey\n\t\t\t\t\t? toKeyLabel(String(source.nameKey))\n\t\t\t\t\t: toKeyLabel(String(source.yKey));\n\n\t\t\treturn {\n\t\t\t\tid: source.id,\n\t\t\t\tseriesIndex: source.seriesIndex,\n\t\t\t\tpoints: sortedPoints,\n\t\t\t\ttotal: totalValue,\n\t\t\t\tseriesLabel: resolvedSeriesLabel,\n\t\t\t\tvalueLabel: toKeyLabel(String(source.yKey)),\n\t\t\t\tcolor: resolveColor(source.color, source.seriesIndex),\n\t\t\t\t...(source.yFormatter ? { yFormatter: source.yFormatter } : {}),\n\t\t\t\t...(source.valueFormatter\n\t\t\t\t\t? { valueFormatter: source.valueFormatter }\n\t\t\t\t\t: {}),\n\t\t\t};\n\t\t};\n\n\t\tconst provisionalSeries: LineChartSeriesComputation<TData>[] = [\n\t\t\tbuildSeries({\n\t\t\t\tid: 'series-0',\n\t\t\t\tseriesIndex: 0,\n\t\t\t\tdata,\n\t\t\t\txKey,\n\t\t\t\tyKey,\n\t\t\t\tsortPoints,\n\t\t\t\t...(nameKey !== undefined ? { nameKey } : {}),\n\t\t\t\t...(color !== undefined ? { color } : {}),\n\t\t\t\t...(seriesLabel !== undefined ? { seriesLabel } : {}),\n\t\t\t\t...(yFormatter ? { yFormatter } : {}),\n\t\t\t\t...(valueFormatter ? { valueFormatter } : {}),\n\t\t\t}),\n\t\t\t...additionalSeries.map((config, index) => {\n\t\t\t\tconst resolvedNameKey = config.nameKey ?? nameKey;\n\t\t\t\treturn buildSeries({\n\t\t\t\t\tid: config.id ?? `series-${index + 1}`,\n\t\t\t\t\tseriesIndex: index + 1,\n\t\t\t\t\tdata: config.data ?? data,\n\t\t\t\t\txKey: config.xKey ?? xKey,\n\t\t\t\t\tyKey: config.yKey,\n\t\t\t\t\tsortPoints: config.sortPoints ?? sortPoints,\n\t\t\t\t\t...(resolvedNameKey !== undefined\n\t\t\t\t\t\t? { nameKey: resolvedNameKey }\n\t\t\t\t\t\t: {}),\n\t\t\t\t\t...(config.color !== undefined ? { color: config.color } : {}),\n\t\t\t\t\t...(config.seriesLabel !== undefined\n\t\t\t\t\t\t? { seriesLabel: config.seriesLabel }\n\t\t\t\t\t\t: {}),\n\t\t\t\t\t...(config.yFormatter ? { yFormatter: config.yFormatter } : {}),\n\t\t\t\t\t...(config.valueFormatter\n\t\t\t\t\t\t? { valueFormatter: config.valueFormatter }\n\t\t\t\t\t\t: {}),\n\t\t\t\t});\n\t\t\t}),\n\t\t];\n\n\t\tconst allPoints = provisionalSeries.flatMap((series) => series.points);\n\t\tconst xValues = allPoints.map((point) => point.x);\n\t\tconst yValues = allPoints.map((point) => point.value);\n\n\t\tconst minX = xValues.length ? Math.min(...xValues) : 0;\n\t\tconst maxX = xValues.length ? Math.max(...xValues) : 1;\n\t\tconst minY = yValues.length ? Math.min(...yValues, 0) : 0;\n\t\tconst maxY = yValues.length ? Math.max(...yValues, 0) : 1;\n\n\t\tconst resolvedXDomain: [number, number] =\n\t\t\tminX === maxX ? [minX - 1, maxX + 1] : [minX, maxX];\n\n\t\tconst rawYRange = maxY - minY;\n\t\tconst magnitudeFallback = Math.max(Math.abs(maxY), Math.abs(minY), 1);\n\t\tconst yPadding =\n\t\t\tNumber.isFinite(rawYRange) && rawYRange > 0\n\t\t\t\t? rawYRange * 0.1\n\t\t\t\t: magnitudeFallback * 0.1;\n\n\t\tconst paddedMaxY = Number.isFinite(maxY) ? maxY + yPadding : maxY;\n\t\tlet paddedMinY = Number.isFinite(minY) ? minY : 0;\n\n\t\tif (minY < 0) {\n\t\t\tpaddedMinY -= yPadding;\n\t\t} else {\n\t\t\tpaddedMinY = Math.min(minY, 0);\n\t\t}\n\n\t\tconst paddedYDomain: [number, number] =\n\t\t\tminY === maxY\n\t\t\t\t? [minY - magnitudeFallback, maxY + magnitudeFallback]\n\t\t\t\t: [paddedMinY, paddedMaxY];\n\n\t\tconst resolvedYDomain = alignDomainToNiceValues(\n\t\t\tpaddedYDomain,\n\t\t\tDEFAULT_Y_TICK_TARGET,\n\t\t);\n\n\t\tconst seriesCollection = provisionalSeries.map(\n\t\t\t({\n\t\t\t\tyFormatter: seriesYFormatter,\n\t\t\t\tvalueFormatter: seriesValueFormatter,\n\t\t\t\t...rest\n\t\t\t}) => ({\n\t\t\t\t...rest,\n\t\t\t\tformatY: (point: LineChartPoint<TData>) => {\n\t\t\t\t\tif (seriesValueFormatter) {\n\t\t\t\t\t\treturn seriesValueFormatter(point, {\n\t\t\t\t\t\t\ttotal: rest.total,\n\t\t\t\t\t\t\tdomain: resolvedYDomain,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (seriesYFormatter) {\n\t\t\t\t\t\treturn seriesYFormatter(point, {\n\t\t\t\t\t\t\ttotal: rest.total,\n\t\t\t\t\t\t\tdomain: resolvedYDomain,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn point.value.toLocaleString();\n\t\t\t\t},\n\t\t\t}),\n\t\t);\n\n\t\treturn {\n\t\t\tseriesCollection,\n\t\t\txDomain: resolvedXDomain,\n\t\t\tyDomain: resolvedYDomain,\n\t\t};\n\t}, [\n\t\tadditionalSeries,\n\t\tcolor,\n\t\tdata,\n\t\tnameKey,\n\t\tseriesLabel,\n\t\tsortPoints,\n\t\tvalueFormatter,\n\t\txKey,\n\t\tyFormatter,\n\t\tyKey,\n\t]);\n\n\tReact.useEffect(() => {\n\t\tif (activePointId) {\n\t\t\tconst matches = seriesCollection.some((series) =>\n\t\t\t\tseries.points.some((point) => point.id === activePointId),\n\t\t\t);\n\t\t\tif (!matches) {\n\t\t\t\tsetActivePointId(null);\n\t\t\t\tsetActivePointX(null);\n\t\t\t}\n\t\t}\n\t\tif (activePointX !== null) {\n\t\t\tconst hasX = seriesCollection.some((series) =>\n\t\t\t\tseries.points.some((point) => point.x === activePointX),\n\t\t\t);\n\t\t\tif (!hasX) {\n\t\t\t\tsetActivePointX(null);\n\t\t\t}\n\t\t}\n\t}, [activePointId, activePointX, seriesCollection]);\n\n\tconst primarySeries = React.useMemo<LineChartSeriesState<TData>>(() => {\n\t\tconst firstSeries = seriesCollection[0];\n\t\tif (firstSeries) {\n\t\t\treturn firstSeries;\n\t\t}\n\t\tconst fallbackLabel = seriesLabel?.trim().length\n\t\t\t? seriesLabel\n\t\t\t: nameKey\n\t\t\t\t? toKeyLabel(String(nameKey))\n\t\t\t\t: toKeyLabel(String(yKey));\n\n\t\treturn {\n\t\t\tid: 'series-0',\n\t\t\tseriesIndex: 0,\n\t\t\tpoints: [],\n\t\t\ttotal: 0,\n\t\t\tseriesLabel: fallbackLabel,\n\t\t\tvalueLabel: toKeyLabel(String(yKey)),\n\t\t\tcolor: resolveColor(color, 0),\n\t\t\tformatY: () => '0',\n\t\t} satisfies LineChartSeriesState<TData>;\n\t}, [seriesCollection, color, nameKey, seriesLabel, yKey]);\n\n\tconst seriesById = React.useMemo(() => {\n\t\tconst map = new Map<string, LineChartSeriesState<TData>>();\n\t\tfor (const series of seriesCollection) {\n\t\t\tmap.set(series.id, series);\n\t\t}\n\t\treturn map;\n\t}, [seriesCollection]);\n\n\tconst formatX = React.useCallback(\n\t\t(point: LineChartPoint<TData>) =>\n\t\t\txFormatter ? xFormatter(point) : getPointLabelText(point),\n\t\t[xFormatter],\n\t);\n\n\tconst formatY = React.useCallback(\n\t\t(point: LineChartPoint<TData>) => primarySeries.formatY(point),\n\t\t[primarySeries],\n\t);\n\n\tconst formatYForSeries = React.useCallback(\n\t\t(seriesId: string, point: LineChartPoint<TData>) => {\n\t\t\tconst target = seriesById.get(seriesId) ?? primarySeries;\n\t\t\treturn target.formatY(point);\n\t\t},\n\t\t[seriesById, primarySeries],\n\t);\n\n\tconst contextValue = React.useMemo<LineChartContextValue<TData>>(\n\t\t() => ({\n\t\t\tseries: seriesCollection,\n\t\t\tpoints: primarySeries.points,\n\t\t\ttotal: primarySeries.total,\n\t\t\tseriesLabel: primarySeries.seriesLabel,\n\t\t\tcolor: primarySeries.color,\n\t\t\txDomain,\n\t\t\tyDomain,\n\t\t\tformatX,\n\t\t\tformatY,\n\t\t\tformatYForSeries,\n\t\t\tvalueLabel: primarySeries.valueLabel,\n\t\t\txLabel,\n\t\t\tactivePointId,\n\t\t\tsetActivePointId,\n\t\t\tactivePointX,\n\t\t\tsetActivePointX,\n\t\t}),\n\t\t[\n\t\t\tactivePointId,\n\t\t\tformatX,\n\t\t\tformatY,\n\t\t\tformatYForSeries,\n\t\t\tprimarySeries,\n\t\t\tseriesCollection,\n\t\t\txDomain,\n\t\t\txLabel,\n\t\t\tyDomain,\n\t\t\tactivePointX,\n\t\t],\n\t);\n\n\treturn (\n\t\t<LineChartContext.Provider\n\t\t\tvalue={contextValue as LineChartContextValue<ChartDatum>}\n\t\t>\n\t\t\t<div\n\t\t\t\tref={ref}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'relative flex flex-col rounded-lg border border-border bg-card shadow-md card-highlight',\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t\t{...rest}\n\t\t\t>\n\t\t\t\t{children}\n\t\t\t</div>\n\t\t</LineChartContext.Provider>\n\t);\n}\n\ntype LineChartComponent = <TData extends ChartDatum = ChartDatum>(\n\tprops: LineChartProps<TData> & { ref?: React.Ref<HTMLDivElement> },\n) => React.ReactElement | null;\n\nconst LineChartRoot = React.forwardRef(\n\tLineChartRootInner,\n) as LineChartComponent;\n\nconst LINE_CHART_ACTIONS_MARKER = Symbol('LineChartActions');\nconst LINE_CHART_TITLE_MARKER = Symbol('LineChartTitle');\nconst LINE_CHART_DESCRIPTION_MARKER = Symbol('LineChartDescription');\n\nexport interface LineChartTitleProps {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n\tas?: React.ElementType;\n}\n\ntype LineChartTitleComponent = React.FC<LineChartTitleProps> & {\n\t[LINE_CHART_TITLE_MARKER]: true;\n};\n\nexport const LineChartTitle = (({\n\tchildren,\n\tclassName = '',\n\tas: Component = 'h3',\n\t...props\n}: LineChartTitleProps) => {\n\treturn React.createElement(\n\t\tComponent,\n\t\t{\n\t\t\tclassName: cn(\n\t\t\t\t'text-base font-medium leading-none text-foreground',\n\t\t\t\tclassName,\n\t\t\t),\n\t\t\t...props,\n\t\t},\n\t\tchildren,\n\t);\n}) as LineChartTitleComponent;\nLineChartTitle.displayName = 'LineChartTitle';\nLineChartTitle[LINE_CHART_TITLE_MARKER] = true;\n\nexport interface LineChartDescriptionProps\n\textends React.HTMLAttributes<HTMLParagraphElement> {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n}\n\ntype LineChartDescriptionComponent = React.FC<LineChartDescriptionProps> & {\n\t[LINE_CHART_DESCRIPTION_MARKER]: true;\n};\n\nexport const LineChartDescription = (({\n\tchildren,\n\tclassName = '',\n\t...props\n}: LineChartDescriptionProps) => {\n\treturn (\n\t\t<p\n\t\t\tclassName={cn(\n\t\t\t\t'text-sm leading-snug text-foreground/45 text-balance',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t</p>\n\t);\n}) as LineChartDescriptionComponent;\nLineChartDescription.displayName = 'LineChartDescription';\nLineChartDescription[LINE_CHART_DESCRIPTION_MARKER] = true;\n\nexport interface LineChartActionsProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n}\n\ntype LineChartActionsComponent = React.FC<LineChartActionsProps> & {\n\t[LINE_CHART_ACTIONS_MARKER]: true;\n};\n\nexport const LineChartActions = (({ children, className = '', ...props }) => {\n\treturn (\n\t\t<div\n\t\t\tclassName={cn(\n\t\t\t\t'flex items-center gap-2 self-start sm:self-auto',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t</div>\n\t);\n}) as LineChartActionsComponent;\nLineChartActions.displayName = 'LineChartActions';\nLineChartActions[LINE_CHART_ACTIONS_MARKER] = true;\n\nfunction hasLineChartMarker(\n\ttarget: unknown,\n\tmarker: symbol,\n): target is { [key: symbol]: unknown } {\n\tif (!target) return false;\n\tif (\n\t\t(typeof target === 'function' || typeof target === 'object') &&\n\t\ttarget !== null &&\n\t\tReflect.get(target, marker)\n\t) {\n\t\treturn true;\n\t}\n\tif (\n\t\ttypeof target === 'object' &&\n\t\ttarget !== null &&\n\t\t'type' in target &&\n\t\t(target as { type?: unknown }).type\n\t) {\n\t\treturn hasLineChartMarker((target as { type?: unknown }).type, marker);\n\t}\n\treturn false;\n}\n\nfunction cloneElementWithClassName<TProps extends { className?: string }>(\n\telement: React.ReactElement<TProps>,\n\tadditionalClassName?: string,\n) {\n\tif (!additionalClassName) {\n\t\treturn element;\n\t}\n\tconst mergedClassName = cn(element.props.className, additionalClassName);\n\treturn React.cloneElement(element, {\n\t\tclassName: mergedClassName,\n\t} as Partial<TProps> & React.Attributes);\n}\n\nfunction isLineChartActionsElement(\n\tchild: React.ReactNode,\n): child is React.ReactElement {\n\tif (!React.isValidElement(child)) return false;\n\tconst { type } = child;\n\tif (type === LineChartActions) return true;\n\tif (hasLineChartMarker(type, LINE_CHART_ACTIONS_MARKER)) return true;\n\tconst displayName =\n\t\ttypeof type === 'function' || (typeof type === 'object' && type !== null)\n\t\t\t? (type as { displayName?: string }).displayName\n\t\t\t: undefined;\n\treturn displayName === LineChartActions.displayName;\n}\n\nfunction isLineChartTitleElement(\n\tchild: React.ReactNode,\n): child is React.ReactElement<LineChartTitleProps> {\n\tif (!React.isValidElement(child)) return false;\n\tconst { type } = child;\n\tif (type === LineChartTitle) return true;\n\tif (hasLineChartMarker(type, LINE_CHART_TITLE_MARKER)) return true;\n\tconst displayName =\n\t\ttypeof type === 'function' || (typeof type === 'object' && type !== null)\n\t\t\t? (type as { displayName?: string }).displayName\n\t\t\t: undefined;\n\treturn displayName === LineChartTitle.displayName;\n}\n\nfunction isLineChartDescriptionElement(\n\tchild: React.ReactNode,\n): child is React.ReactElement<LineChartDescriptionProps> {\n\tif (!React.isValidElement(child)) return false;\n\tconst { type } = child;\n\tif (type === LineChartDescription) return true;\n\tif (hasLineChartMarker(type, LINE_CHART_DESCRIPTION_MARKER)) return true;\n\tconst displayName =\n\t\ttypeof type === 'function' || (typeof type === 'object' && type !== null)\n\t\t\t? (type as { displayName?: string }).displayName\n\t\t\t: undefined;\n\treturn displayName === LineChartDescription.displayName;\n}\n\nexport interface LineChartHeaderProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tcontentClassName?: string;\n\ttitleClassName?: string;\n\tdescriptionClassName?: string;\n\tactionsClassName?: string;\n}\n\nexport const LineChartHeader = React.forwardRef<\n\tHTMLDivElement,\n\tLineChartHeaderProps\n>(\n\t(\n\t\t{\n\t\t\tclassName = '',\n\t\t\tchildren,\n\t\t\tcontentClassName,\n\t\t\ttitleClassName,\n\t\t\tdescriptionClassName,\n\t\t\tactionsClassName,\n\t\t\t...props\n\t\t},\n\t\tref,\n\t) => {\n\t\tconst childrenArray = React.Children.toArray(children);\n\t\tconst mainChildren: React.ReactNode[] = [];\n\t\tconst actionChildren: React.ReactNode[] = [];\n\n\t\tchildrenArray.forEach((child) => {\n\t\t\tif (isLineChartActionsElement(child)) {\n\t\t\t\tactionChildren.push(child);\n\t\t\t} else if (child !== null) {\n\t\t\t\tmainChildren.push(child);\n\t\t\t}\n\t\t});\n\n\t\tconst enhancedMainChildren = mainChildren.map((child) => {\n\t\t\tif (isLineChartTitleElement(child)) {\n\t\t\t\treturn cloneElementWithClassName(\n\t\t\t\t\tchild as React.ReactElement<{ className?: string }>,\n\t\t\t\t\ttitleClassName,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (isLineChartDescriptionElement(child)) {\n\t\t\t\treturn cloneElementWithClassName(\n\t\t\t\t\tchild as React.ReactElement<{ className?: string }>,\n\t\t\t\t\tdescriptionClassName,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn child;\n\t\t});\n\n\t\tconst enhancedActionChildren = actionChildren.map((child) => {\n\t\t\tif (isLineChartActionsElement(child)) {\n\t\t\t\treturn cloneElementWithClassName(\n\t\t\t\t\tchild as React.ReactElement<{ className?: string }>,\n\t\t\t\t\tactionsClassName,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn child;\n\t\t});\n\n\t\treturn (\n\t\t\t<div\n\t\t\t\tref={ref}\n\t\t\t\tclassName={cn(\n\t\t\t\t\t'flex flex-col gap-3 px-4 pt-4 sm:flex-row sm:items-start sm:justify-between sm:gap-4',\n\t\t\t\t\tclassName,\n\t\t\t\t)}\n\t\t\t\t{...props}\n\t\t\t>\n\t\t\t\t{enhancedMainChildren.length ? (\n\t\t\t\t\t<div className={cn('space-y-1 sm:flex-1', contentClassName)}>\n\t\t\t\t\t\t{enhancedMainChildren}\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t\t{enhancedActionChildren.length ? enhancedActionChildren : null}\n\t\t\t</div>\n\t\t);\n\t},\n);\nLineChartHeader.displayName = 'LineChartHeader';\n\nexport interface LineChartTooltipSeriesEntry<\n\tTData extends ChartDatum = ChartDatum,\n> {\n\tseriesId: string;\n\tseriesLabel: string;\n\tseriesColor: string;\n\tvalueLabel: string;\n\tpoint: LineChartPoint<TData>;\n\tvalue: number;\n\tformattedValue: React.ReactNode;\n\tformattedValueText: string;\n}\n\nexport interface LineChartTooltipInfo<TData extends ChartDatum = ChartDatum> {\n\tpoint: LineChartPoint<TData>;\n\tvalue: number;\n\tseriesId: string;\n\tseriesLabel: string;\n\tseriesColor: string;\n\tvalueLabel: string;\n\tformattedX: React.ReactNode;\n\tformattedY: React.ReactNode;\n\tformattedXText: string;\n\tformattedYText: string;\n\tseriesEntries: LineChartTooltipSeriesEntry<TData>[];\n}\n\nexport interface LineChartGraphProps<TData extends ChartDatum = ChartDatum>\n\textends React.HTMLAttributes<HTMLDivElement> {\n\theight?: number | string;\n\tcurve?: LineChartCurve;\n\tshowTooltip?: boolean;\n\ttooltipRender?: (info: LineChartTooltipInfo<TData>) => React.ReactNode;\n\tshowDots?: boolean;\n\tloading?: boolean;\n\tloadingState?: React.ReactNode;\n\temptyState?: React.ReactNode;\n\terror?: React.ReactNode;\n\tariaLabel?: string;\n\tshowGrid?: boolean;\n\tshowXAxisValues?: boolean;\n\tshowYAxisValues?: boolean;\n\txTickCount?: number;\n\tyTickCount?: number;\n\tchildren?: React.ReactNode;\n}\n\nfunction LineChartState({\n\tlabel,\n\tdescription,\n}: {\n\tlabel: string;\n\tdescription?: React.ReactNode;\n}) {\n\treturn (\n\t\t<div className=\"flex h-full w-full items-center justify-center rounded-md border border-dashed border-border/60 bg-card-muted/30 px-4 py-10 text-center\">\n\t\t\t<div className=\"space-y-2\">\n\t\t\t\t<p className=\"text-sm leading-none font-medium text-foreground\">\n\t\t\t\t\t{label}\n\t\t\t\t</p>\n\t\t\t\t{description ? (\n\t\t\t\t\t<p className=\"text-sm leading-snug text-foreground/45 text-balance\">\n\t\t\t\t\t\t{description}\n\t\t\t\t\t</p>\n\t\t\t\t) : null}\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport const LineChartGraphBase = React.forwardRef<\n\tHTMLDivElement,\n\tLineChartGraphProps<ChartDatum>\n>(function LineChartGraphInner(\n\t{\n\t\theight,\n\t\tcurve = 'monotone',\n\t\tshowTooltip = true,\n\t\ttooltipRender,\n\t\tshowDots = true,\n\t\tloading = false,\n\t\tloadingState,\n\t\temptyState,\n\t\terror,\n\t\tariaLabel,\n\t\tshowGrid = true,\n\t\tshowXAxisValues = true,\n\t\tshowYAxisValues = true,\n\t\txTickCount = 4,\n\t\tyTickCount = DEFAULT_Y_TICK_TARGET,\n\t\tchildren,\n\t\tclassName,\n\t\tstyle,\n\t\t...rest\n\t}: LineChartGraphProps<ChartDatum>,\n\tref,\n) {\n\tconst {\n\t\tseries,\n\t\tformatX,\n\t\tformatYForSeries,\n\t\txDomain,\n\t\tyDomain,\n\t\tactivePointId,\n\t\tsetActivePointId,\n\t\tactivePointX,\n\t\tsetActivePointX,\n\t} = useLineChartContext();\n\n\tconst svgRef = React.useRef<SVGSVGElement | null>(null);\n\tconst outerRef = React.useRef<HTMLDivElement | null>(null);\n\tconst chartContainerRef = React.useRef<HTMLDivElement | null>(null);\n\tconst [chartDimensions, setChartDimensions] = React.useState({\n\t\twidth: 0,\n\t\theight: 0,\n\t});\n\tconst combinedRef = React.useCallback(\n\t\t(node: HTMLDivElement | null) => {\n\t\t\touterRef.current = node;\n\t\t\tif (typeof ref === 'function') {\n\t\t\t\tref(node);\n\t\t\t} else if (ref) {\n\t\t\t\t(ref as React.RefObject<HTMLDivElement | null>).current = node;\n\t\t\t}\n\t\t},\n\t\t[ref],\n\t);\n\n\tconst resolvedHeight =\n\t\ttypeof height === 'number'\n\t\t\t? `${height}px`\n\t\t\t: (height ?? `${DEFAULT_HEIGHT}px`);\n\n\tReact.useLayoutEffect(() => {\n\t\tconst node = chartContainerRef.current;\n\t\tif (!node) {\n\t\t\treturn;\n\t\t}\n\t\tconst rect = node.getBoundingClientRect();\n\t\tsetChartDimensions((previous) => {\n\t\t\tif (\n\t\t\t\tMath.abs(previous.width - rect.width) < 0.5 &&\n\t\t\t\tMath.abs(previous.height - rect.height) < 0.5\n\t\t\t) {\n\t\t\t\treturn previous;\n\t\t\t}\n\t\t\treturn {\n\t\t\t\twidth: rect.width || FALLBACK_CHART_DIMENSIONS.width,\n\t\t\t\theight: rect.height || FALLBACK_CHART_DIMENSIONS.height,\n\t\t\t};\n\t\t});\n\n\t\tif (typeof ResizeObserver === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tconst observer = new ResizeObserver(([entry]) => {\n\t\t\tif (!entry) return;\n\t\t\tconst { width, height: observedHeight } = entry.contentRect;\n\t\t\tsetChartDimensions((previous) => {\n\t\t\t\tif (\n\t\t\t\t\tMath.abs(previous.width - width) < 0.5 &&\n\t\t\t\t\tMath.abs(previous.height - observedHeight) < 0.5\n\t\t\t\t) {\n\t\t\t\t\treturn previous;\n\t\t\t\t}\n\t\t\t\treturn { width, height: observedHeight };\n\t\t\t});\n\t\t});\n\t\tobserver.observe(node);\n\t\treturn () => observer.disconnect();\n\t}, []);\n\n\tconst trimmedAriaLabel = ariaLabel?.trim();\n\tconst svgTitleId = React.useId();\n\tconst svgTitle =\n\t\ttrimmedAriaLabel && trimmedAriaLabel.length > 0\n\t\t\t? trimmedAriaLabel\n\t\t\t: 'Line chart visualization';\n\n\tconst measuredWidth =\n\t\tchartDimensions.width || FALLBACK_CHART_DIMENSIONS.width;\n\tconst measuredHeight =\n\t\tchartDimensions.height || FALLBACK_CHART_DIMENSIONS.height;\n\n\tconst axisTickLength = 0;\n\tconst showXAxisLabels = showXAxisValues;\n\tconst showYAxisLabels = showYAxisValues;\n\tconst chartHorizontalGap = showYAxisLabels ? Y_AXIS_CHART_GAP : 0;\n\tconst [yAxisLabelWidth, setYAxisLabelWidth] = React.useState(0);\n\tconst padding = React.useMemo(\n\t\t() => ({\n\t\t\t...CHART_PADDING,\n\t\t\tleft: Math.max(\n\t\t\t\tCHART_PADDING.left,\n\t\t\t\tMath.ceil(yAxisLabelWidth) + axisTickLength + 6,\n\t\t\t),\n\t\t}),\n\t\t[yAxisLabelWidth],\n\t);\n\n\tconst viewBoxWidth = Math.max(\n\t\tmeasuredWidth,\n\t\tpadding.left + padding.right + 1,\n\t);\n\tconst viewBoxHeight = Math.max(\n\t\tmeasuredHeight,\n\t\tpadding.top + padding.bottom + 1,\n\t);\n\n\tconst availableChartWidth = Math.max(\n\t\t1,\n\t\tviewBoxWidth - padding.left - padding.right,\n\t);\n\tconst chartWidth = Math.max(1, availableChartWidth - chartHorizontalGap);\n\tconst chartStartX = padding.left + chartHorizontalGap;\n\tconst chartHeight = Math.max(1, viewBoxHeight - padding.top - padding.bottom);\n\tconst chartRight = chartStartX + chartWidth;\n\tconst chartBottom = padding.top + chartHeight;\n\tconst yTickLabelX = Math.max(\n\t\tchartStartX - chartHorizontalGap - axisTickLength - 4,\n\t\t4,\n\t);\n\n\tconst scaleX = React.useMemo(\n\t\t() => createLinearScale(xDomain, [0, chartWidth]),\n\t\t[chartWidth, xDomain],\n\t);\n\tconst scaleY = React.useMemo(\n\t\t() => createLinearScale(yDomain, [chartHeight, 0]),\n\t\t[chartHeight, yDomain],\n\t);\n\n\tconst curveFactory = CURVE_FACTORIES[curve] ?? curveMonotoneX;\n\n\ttype PositionedSeries = LineChartSeriesState<ChartDatum> & {\n\t\tgradientId: string;\n\t\tpositionedPoints: Array<{\n\t\t\tpoint: LineChartPoint;\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t}>;\n\t\tlinePath?: string;\n\t};\n\n\tconst gradientBaseId = React.useId();\n\n\tconst computedSeries = React.useMemo<PositionedSeries[]>(() => {\n\t\treturn series.map((seriesItem, index) => {\n\t\t\tconst positionedPoints = seriesItem.points.map((point) => ({\n\t\t\t\tpoint,\n\t\t\t\tx: chartStartX + scaleX(point.x),\n\t\t\t\ty: padding.top + scaleY(point.y),\n\t\t\t}));\n\n\t\t\tlet linePath: string | undefined;\n\n\t\t\tif (seriesItem.points.length > 1) {\n\t\t\t\tconst lineGenerator = line<LineChartPoint>()\n\t\t\t\t\t.x((point: LineChartPoint) => chartStartX + scaleX(point.x))\n\t\t\t\t\t.y((point: LineChartPoint) => padding.top + scaleY(point.y))\n\t\t\t\t\t.curve(curveFactory);\n\t\t\t\tlinePath = lineGenerator(seriesItem.points) ?? undefined;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...seriesItem,\n\t\t\t\tgradientId: `${gradientBaseId}-${index}`,\n\t\t\t\tpositionedPoints,\n\t\t\t\t...(linePath ? { linePath } : {}),\n\t\t\t};\n\t\t});\n\t}, [\n\t\tchartStartX,\n\t\tcurveFactory,\n\t\tseries,\n\t\tpadding.top,\n\t\tscaleX,\n\t\tscaleY,\n\t\tgradientBaseId,\n\t]);\n\n\tconst hasEnoughPoints = computedSeries.some(\n\t\t(seriesItem) => seriesItem.points.length > 1,\n\t);\n\tconst showChart = !loading && !error && hasEnoughPoints;\n\n\tconst positionedPointsAll = React.useMemo(\n\t\t() =>\n\t\t\tcomputedSeries.flatMap((seriesItem) =>\n\t\t\t\tseriesItem.positionedPoints.map((entry) => ({\n\t\t\t\t\tseries: seriesItem,\n\t\t\t\t\t...entry,\n\t\t\t\t})),\n\t\t\t),\n\t\t[computedSeries],\n\t);\n\tconst shouldComputeXTicks = showXAxisLabels;\n\tconst shouldComputeYTicks = showGrid || showYAxisLabels;\n\n\tconst xAxisTicks = React.useMemo(() => {\n\t\tconst basePoints = series[0]?.points ?? [];\n\t\tif (!shouldComputeXTicks || basePoints.length === 0) return [];\n\t\tconst selected = selectPointsForTicks(basePoints, xTickCount);\n\t\treturn selected.map((point) => {\n\t\t\tconst label = toPlainText(formatX(point), getPointLabelText(point));\n\t\t\treturn {\n\t\t\t\tid: point.id,\n\t\t\t\tposition: chartStartX + scaleX(point.x),\n\t\t\t\tlabel,\n\t\t\t};\n\t\t});\n\t}, [chartStartX, formatX, scaleX, series, shouldComputeXTicks, xTickCount]);\n\n\tconst yAxisTicks = React.useMemo(() => {\n\t\tif (!shouldComputeYTicks) return [];\n\t\tconst ticks = generateLinearTicks(yDomain, yTickCount);\n\t\treturn ticks.map((value) => {\n\t\t\tconst relativePosition = clamp(scaleY(value), 0, chartHeight);\n\t\t\treturn {\n\t\t\t\tvalue,\n\t\t\t\tposition: padding.top + relativePosition,\n\t\t\t\tlabel: Number.isFinite(value)\n\t\t\t\t\t? value.toLocaleString(undefined, {\n\t\t\t\t\t\t\tmaximumFractionDigits: Math.abs(value) >= 100 ? 0 : 2,\n\t\t\t\t\t\t})\n\t\t\t\t\t: String(value),\n\t\t\t};\n\t\t});\n\t}, [\n\t\tchartHeight,\n\t\tpadding.top,\n\t\tscaleY,\n\t\tshouldComputeYTicks,\n\t\tyDomain,\n\t\tyTickCount,\n\t]);\n\n\tReact.useLayoutEffect(() => {\n\t\tif (!showYAxisLabels) {\n\t\t\tsetYAxisLabelWidth((previous) => (previous === 0 ? previous : 0));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!svgRef.current) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelNodes = svgRef.current.querySelectorAll<SVGTextElement>(\n\t\t\t'[data-line-chart-y-label]',\n\t\t);\n\t\tlet maxWidth = 0;\n\t\tlabelNodes.forEach((node) => {\n\t\t\tconst box = node.getBBox();\n\t\t\tif (Number.isFinite(box.width)) {\n\t\t\t\tmaxWidth = Math.max(maxWidth, box.width);\n\t\t\t}\n\t\t});\n\n\t\tsetYAxisLabelWidth((previous) =>\n\t\t\tMath.abs(previous - maxWidth) > 0.5 ? maxWidth : previous,\n\t\t);\n\t}, [showYAxisLabels]);\n\n\tconst tooltipRef = React.useRef<HTMLDivElement | null>(null);\n\tconst [tooltipDimensions, setTooltipDimensions] = React.useState({\n\t\twidth: 0,\n\t\theight: 0,\n\t});\n\tconst [tooltip, setTooltip] = React.useState<{\n\t\tinfo: LineChartTooltipInfo;\n\t\tx: number;\n\t\ty: number;\n\t\thorizontal: 'left' | 'right';\n\t\tvertical: 'top' | 'bottom';\n\t\tvisible: boolean;\n\t\tentering: boolean;\n\t} | null>(null);\n\tconst hideTooltipTimeoutRef = React.useRef<number | null>(null);\n\n\tconst cancelScheduledTooltipHide = React.useCallback(() => {\n\t\tif (hideTooltipTimeoutRef.current !== null) {\n\t\t\twindow.clearTimeout(hideTooltipTimeoutRef.current);\n\t\t\thideTooltipTimeoutRef.current = null;\n\t\t}\n\t}, []);\n\n\tconst clearTooltip = React.useCallback(() => {\n\t\tcancelScheduledTooltipHide();\n\t\tsetTooltip((previous) =>\n\t\t\tprevious ? { ...previous, visible: false, entering: false } : null,\n\t\t);\n\t\tsetActivePointId(null);\n\t\tsetActivePointX(null);\n\t}, [cancelScheduledTooltipHide, setActivePointId, setActivePointX]);\n\n\tconst scheduleTooltipHide = React.useCallback(\n\t\t(delay = 140) => {\n\t\t\tcancelScheduledTooltipHide();\n\t\t\thideTooltipTimeoutRef.current = window.setTimeout(() => {\n\t\t\t\tclearTooltip();\n\t\t\t}, delay);\n\t\t},\n\t\t[cancelScheduledTooltipHide, clearTooltip],\n\t);\n\n\tReact.useEffect(() => {\n\t\tif (!tooltip || tooltip.visible || tooltip.entering) return;\n\t\tconst timeoutId = window.setTimeout(() => {\n\t\t\tsetTooltip(null);\n\t\t}, 200);\n\t\treturn () => window.clearTimeout(timeoutId);\n\t}, [tooltip]);\n\n\tReact.useLayoutEffect(() => {\n\t\tif (!tooltipRef.current || typeof ResizeObserver === 'undefined') return;\n\t\tconst observer = new ResizeObserver(([entry]) => {\n\t\t\tif (!entry) return;\n\t\t\tconst { width, height: obsHeight } = entry.contentRect;\n\t\t\tsetTooltipDimensions((previous) =>\n\t\t\t\tMath.abs(previous.width - width) < 0.5 &&\n\t\t\t\tMath.abs(previous.height - obsHeight) < 0.5\n\t\t\t\t\t? previous\n\t\t\t\t\t: { width, height: obsHeight },\n\t\t\t);\n\t\t});\n\t\tobserver.observe(tooltipRef.current);\n\t\treturn () => observer.disconnect();\n\t}, []);\n\n\tReact.useLayoutEffect(() => {\n\t\tif (!tooltip || !tooltip.entering) return;\n\t\tconst frameId = window.requestAnimationFrame(() => {\n\t\t\tsetTooltip((previous) =>\n\t\t\t\tprevious?.entering\n\t\t\t\t\t? { ...previous, visible: true, entering: false }\n\t\t\t\t\t: previous,\n\t\t\t);\n\t\t});\n\t\treturn () => window.cancelAnimationFrame(frameId);\n\t}, [tooltip]);\n\n\tReact.useEffect(\n\t\t() => () => {\n\t\t\tcancelScheduledTooltipHide();\n\t\t},\n\t\t[cancelScheduledTooltipHide],\n\t);\n\n\tconst calculateTooltipPosition = React.useCallback(\n\t\t(viewBoxPoint: { x: number; y: number }) => {\n\t\t\tif (!outerRef.current || !svgRef.current) return null;\n\t\t\tconst containerRect = outerRef.current.getBoundingClientRect();\n\t\t\tconst svgRect = svgRef.current.getBoundingClientRect();\n\t\t\tconst scaleX = viewBoxWidth > 0 ? svgRect.width / viewBoxWidth : 1;\n\t\t\tconst scaleY = viewBoxHeight > 0 ? svgRect.height / viewBoxHeight : 1;\n\t\t\tconst anchorX =\n\t\t\t\tsvgRect.left - containerRect.left + viewBoxPoint.x * scaleX;\n\t\t\tconst anchorY = svgRect.top - containerRect.top + viewBoxPoint.y * scaleY;\n\t\t\tconst tooltipPadding = 12;\n\t\t\tconst tooltipOffset = 0;\n\t\t\tconst pointGap = 0;\n\t\t\tconst estimatedWidth = tooltipDimensions.width || 200;\n\t\t\tconst estimatedHeight = tooltipDimensions.height || 84;\n\n\t\t\tconst minX = tooltipPadding;\n\t\t\tconst maxX = containerRect.width - estimatedWidth - tooltipPadding;\n\t\t\tconst minY = tooltipPadding;\n\t\t\tconst maxY = containerRect.height - estimatedHeight - tooltipPadding;\n\n\t\t\ttype Placement = {\n\t\t\t\thorizontal: 'left' | 'right';\n\t\t\t\tvertical: 'top' | 'bottom';\n\t\t\t};\n\n\t\t\tconst placements: Placement[] = [\n\t\t\t\t{ horizontal: 'left', vertical: 'top' },\n\t\t\t\t{ horizontal: 'right', vertical: 'top' },\n\t\t\t\t{ horizontal: 'left', vertical: 'bottom' },\n\t\t\t\t{ horizontal: 'right', vertical: 'bottom' },\n\t\t\t];\n\n\t\t\tconst tryPlacement = (\n\t\t\t\tplacement: Placement,\n\t\t\t\tallowOverflow: boolean,\n\t\t\t): {\n\t\t\t\tx: number;\n\t\t\t\ty: number;\n\t\t\t\thorizontal: Placement['horizontal'];\n\t\t\t\tvertical: Placement['vertical'];\n\t\t\t} | null => {\n\t\t\t\tconst candidateX =\n\t\t\t\t\tplacement.horizontal === 'left'\n\t\t\t\t\t\t? anchorX - estimatedWidth - tooltipOffset\n\t\t\t\t\t\t: anchorX + tooltipOffset;\n\t\t\t\tconst candidateY =\n\t\t\t\t\tplacement.vertical === 'top'\n\t\t\t\t\t\t? anchorY - estimatedHeight - tooltipOffset\n\t\t\t\t\t\t: anchorY + tooltipOffset;\n\n\t\t\t\tif (!allowOverflow) {\n\t\t\t\t\tif (candidateX < minX || candidateX > maxX) return null;\n\t\t\t\t\tif (candidateY < minY || candidateY > maxY) return null;\n\t\t\t\t}\n\n\t\t\t\tlet x = clamp(candidateX, minX, maxX);\n\t\t\t\tlet y = clamp(candidateY, minY, maxY);\n\n\t\t\t\tif (placement.horizontal === 'left') {\n\t\t\t\t\tx = Math.min(x, anchorX - pointGap - estimatedWidth);\n\t\t\t\t} else {\n\t\t\t\t\tx = Math.max(x, anchorX + pointGap);\n\t\t\t\t}\n\t\t\t\tx = clamp(x, minX, maxX);\n\n\t\t\t\tif (placement.vertical === 'top') {\n\t\t\t\t\ty = Math.min(y, anchorY - pointGap - estimatedHeight);\n\t\t\t\t} else {\n\t\t\t\t\ty = Math.max(y, anchorY + pointGap);\n\t\t\t\t}\n\t\t\t\ty = clamp(y, minY, maxY);\n\n\t\t\t\tconst coversPoint =\n\t\t\t\t\tanchorX >= x &&\n\t\t\t\t\tanchorX <= x + estimatedWidth &&\n\t\t\t\t\tanchorY >= y &&\n\t\t\t\t\tanchorY <= y + estimatedHeight;\n\n\t\t\t\tif (coversPoint) return null;\n\n\t\t\t\treturn {\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\thorizontal: placement.horizontal,\n\t\t\t\t\tvertical: placement.vertical,\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tfor (const placement of placements) {\n\t\t\t\tconst position = tryPlacement(placement, false);\n\t\t\t\tif (position) return position;\n\t\t\t}\n\n\t\t\tfor (const placement of placements) {\n\t\t\t\tconst position = tryPlacement(placement, true);\n\t\t\t\tif (position) return position;\n\t\t\t}\n\n\t\t\tconst fallbackHorizontal =\n\t\t\t\tanchorX + pointGap <= maxX ? ('right' as const) : ('left' as const);\n\t\t\tconst fallbackVertical =\n\t\t\t\tanchorY - pointGap - estimatedHeight >= minY\n\t\t\t\t\t? ('top' as const)\n\t\t\t\t\t: anchorY + pointGap <= maxY\n\t\t\t\t\t\t? ('bottom' as const)\n\t\t\t\t\t\t: ('top' as const);\n\n\t\t\tlet fallbackX =\n\t\t\t\tfallbackHorizontal === 'right'\n\t\t\t\t\t? anchorX + pointGap\n\t\t\t\t\t: anchorX - estimatedWidth - pointGap;\n\t\t\tlet fallbackY =\n\t\t\t\tfallbackVertical === 'top'\n\t\t\t\t\t? anchorY - estimatedHeight - pointGap\n\t\t\t\t\t: anchorY + pointGap;\n\n\t\t\tfallbackX = clamp(fallbackX, minX, maxX);\n\t\t\tfallbackY = clamp(fallbackY, minY, maxY);\n\n\t\t\treturn {\n\t\t\t\tx: fallbackX,\n\t\t\t\ty: fallbackY,\n\t\t\t\thorizontal: fallbackHorizontal,\n\t\t\t\tvertical: fallbackVertical,\n\t\t\t};\n\t\t},\n\t\t[\n\t\t\ttooltipDimensions.height,\n\t\t\ttooltipDimensions.width,\n\t\t\tviewBoxHeight,\n\t\t\tviewBoxWidth,\n\t\t],\n\t);\n\n\tconst updateTooltipForPoint = React.useCallback(\n\t\t(\n\t\t\tseriesItem: PositionedSeries,\n\t\t\tpoint: LineChartPoint,\n\t\t\tviewBoxPoint: { x: number; y: number },\n\t\t) => {\n\t\t\tcancelScheduledTooltipHide();\n\t\t\tsetActivePointId(point.id);\n\t\t\tsetActivePointX(point.x);\n\n\t\t\tif (!showTooltip) return;\n\n\t\t\tconst position = calculateTooltipPosition(viewBoxPoint);\n\t\t\tif (!position) return;\n\n\t\t\tconst formattedXNode = formatX(point);\n\t\t\tconst formattedYNode = formatYForSeries(seriesItem.id, point);\n\t\t\tconst formattedXText = toPlainText(\n\t\t\t\tformattedXNode,\n\t\t\t\tgetPointLabelText(point),\n\t\t\t);\n\t\t\tconst formattedYText = toPlainText(\n\t\t\t\tformattedYNode,\n\t\t\t\tgetPointValueText(point),\n\t\t\t);\n\n\t\t\tconst seriesEntries = computedSeries.flatMap<LineChartTooltipSeriesEntry>(\n\t\t\t\t(candidate) => {\n\t\t\t\t\tconst matched = candidate.points.find(\n\t\t\t\t\t\t(candidatePoint) => candidatePoint.x === point.x,\n\t\t\t\t\t);\n\t\t\t\t\tif (!matched) return [];\n\t\t\t\t\tconst formattedValueNode = formatYForSeries(candidate.id, matched);\n\t\t\t\t\tconst formattedValueText = toPlainText(\n\t\t\t\t\t\tformattedValueNode,\n\t\t\t\t\t\tgetPointValueText(matched),\n\t\t\t\t\t);\n\t\t\t\t\treturn [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseriesId: candidate.id,\n\t\t\t\t\t\t\tseriesLabel: candidate.seriesLabel,\n\t\t\t\t\t\t\tseriesColor: candidate.color,\n\t\t\t\t\t\t\tvalueLabel: candidate.valueLabel,\n\t\t\t\t\t\t\tpoint: matched,\n\t\t\t\t\t\t\tvalue: matched.value,\n\t\t\t\t\t\t\tformattedValue: formattedValueNode,\n\t\t\t\t\t\t\tformattedValueText,\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tsetTooltip((previous) => {\n\t\t\t\tconst shouldAnimateIn = !previous || !previous.visible;\n\t\t\t\tconst next = {\n\t\t\t\t\tinfo: {\n\t\t\t\t\t\tpoint,\n\t\t\t\t\t\tvalue: point.value,\n\t\t\t\t\t\tseriesId: seriesItem.id,\n\t\t\t\t\t\tseriesLabel: seriesItem.seriesLabel,\n\t\t\t\t\t\tseriesColor: seriesItem.color,\n\t\t\t\t\t\tvalueLabel: seriesItem.valueLabel,\n\t\t\t\t\t\tformattedX: formattedXNode,\n\t\t\t\t\t\tformattedY: formattedYNode,\n\t\t\t\t\t\tformattedXText,\n\t\t\t\t\t\tformattedYText,\n\t\t\t\t\t\tseriesEntries,\n\t\t\t\t\t},\n\t\t\t\t\tx: position.x,\n\t\t\t\t\ty: position.y,\n\t\t\t\t\thorizontal: position.horizontal,\n\t\t\t\t\tvertical: position.vertical,\n\t\t\t\t\tvisible: !shouldAnimateIn,\n\t\t\t\t\tentering: shouldAnimateIn,\n\t\t\t\t};\n\n\t\t\t\tif (\n\t\t\t\t\tprevious &&\n\t\t\t\t\tprevious.info.point.id === point.id &&\n\t\t\t\t\tMath.abs(previous.x - next.x) < 0.5 &&\n\t\t\t\t\tMath.abs(previous.y - next.y) < 0.5 &&\n\t\t\t\t\tprevious.horizontal === next.horizontal &&\n\t\t\t\t\tprevious.vertical === next.vertical\n\t\t\t\t) {\n\t\t\t\t\tif (shouldAnimateIn) {\n\t\t\t\t\t\treturn next;\n\t\t\t\t\t}\n\t\t\t\t\tif (!previous.visible) {\n\t\t\t\t\t\treturn { ...previous, visible: true, entering: false };\n\t\t\t\t\t}\n\t\t\t\t\treturn previous;\n\t\t\t\t}\n\t\t\t\treturn next;\n\t\t\t});\n\t\t},\n\t\t[\n\t\t\tcalculateTooltipPosition,\n\t\t\tcancelScheduledTooltipHide,\n\t\t\tformatX,\n\t\t\tformatYForSeries,\n\t\t\tcomputedSeries,\n\t\t\tsetActivePointId,\n\t\t\tsetActivePointX,\n\t\t\tshowTooltip,\n\t\t],\n\t);\n\n\tconst handlePointerMove = React.useCallback(\n\t\t(event: React.PointerEvent<SVGRectElement>) => {\n\t\t\tconst targetRect = event.currentTarget.getBoundingClientRect();\n\t\t\tif (targetRect.width === 0 || chartWidth === 0) return;\n\t\t\tconst localX = event.clientX - targetRect.left;\n\t\t\tconst scale = chartWidth / targetRect.width;\n\t\t\tconst pointerViewBoxX = chartStartX + localX * scale;\n\n\t\t\tlet closest = null as {\n\t\t\t\tseries: PositionedSeries;\n\t\t\t\tpoint: LineChartPoint;\n\t\t\t\tviewBox: { x: number; y: number };\n\t\t\t\tdistance: number;\n\t\t\t} | null;\n\n\t\t\tpositionedPointsAll.forEach(({ series: seriesItem, point, x, y }) => {\n\t\t\t\tconst distance = Math.abs(x - pointerViewBoxX);\n\t\t\t\tif (closest === null || distance < closest.distance) {\n\t\t\t\t\tclosest = { series: seriesItem, point, viewBox: { x, y }, distance };\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!closest) return;\n\n\t\t\tupdateTooltipForPoint(closest.series, closest.point, closest.viewBox);\n\t\t},\n\t\t[chartStartX, chartWidth, positionedPointsAll, updateTooltipForPoint],\n\t);\n\n\tconst handlePointerLeave = React.useCallback(\n\t\t(event: React.PointerEvent<Element>) => {\n\t\t\tif (event.pointerType === 'touch' || event.pointerType === 'pen') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tscheduleTooltipHide();\n\t\t},\n\t\t[scheduleTooltipHide],\n\t);\n\n\tconst renderTooltip =\n\t\tshowTooltip && tooltip && tooltipRender\n\t\t\t? tooltipRender(tooltip.info as LineChartTooltipInfo)\n\t\t\t: tooltip && (\n\t\t\t\t\t<div className=\"space-y-2\">\n\t\t\t\t\t\t<div className=\"text-xs font-medium text-foreground\">\n\t\t\t\t\t\t\t{tooltip.info.formattedX}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"space-y-1\">\n\t\t\t\t\t\t\t{tooltip.info.seriesEntries.map((entry) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tkey={entry.seriesId}\n\t\t\t\t\t\t\t\t\t\tclassName=\"flex items-center justify-between gap-3\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<div className=\"flex items-center gap-2\">\n\t\t\t\t\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"inline-flex h-2.5 w-1 shrink-0 rounded-[1px]\"\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{ backgroundColor: entry.seriesColor }}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t<span className={cn('text-xs text-foreground/70')}>\n\t\t\t\t\t\t\t\t\t\t\t\t{entry.seriesLabel}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<span className={cn('text-xs text-foreground/45')}>\n\t\t\t\t\t\t\t\t\t\t\t{entry.formattedValue}\n\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t);\n\n\tReact.useEffect(() => {\n\t\tif (!showChart) {\n\t\t\tsetTooltip(null);\n\t\t}\n\t}, [showChart]);\n\n\tReact.useEffect(() => {\n\t\tif (!tooltip) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst handlePointerDown = (event: PointerEvent) => {\n\t\t\tconst container = outerRef.current;\n\t\t\tif (!container) return;\n\t\t\tconst { target } = event;\n\t\t\tif (target instanceof Node && container.contains(target)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tclearTooltip();\n\t\t};\n\n\t\twindow.addEventListener('pointerdown', handlePointerDown);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener('pointerdown', handlePointerDown);\n\t\t};\n\t}, [clearTooltip, tooltip]);\n\n\tlet body: React.ReactNode = null;\n\n\tif (error) {\n\t\tbody =\n\t\t\ttypeof error === 'string' ? (\n\t\t\t\t<LineChartState\n\t\t\t\t\tlabel=\"There was a problem rendering the chart.\"\n\t\t\t\t\tdescription={error}\n\t\t\t\t/>\n\t\t\t) : (\n\t\t\t\terror\n\t\t\t);\n\t} else if (loading) {\n\t\tbody = loadingState ?? (\n\t\t\t<LineChartState label=\"Loading chart data\" description={undefined} />\n\t\t);\n\t} else if (!hasEnoughPoints) {\n\t\tbody = emptyState ?? (\n\t\t\t<LineChartState\n\t\t\t\tlabel=\"Not enough data to display yet.\"\n\t\t\t\tdescription=\"Provide at least two data points or adjust your filters.\"\n\t\t\t/>\n\t\t);\n\t} else {\n\t\tbody = (\n\t\t\t/* biome-ignore lint/a11y/noSvgWithoutTitle: handled via aria-label */\n\t\t\t<svg\n\t\t\t\tref={svgRef}\n\t\t\t\tclassName=\"h-full w-full text-foreground/45\"\n\t\t\t\tviewBox={`0 0 ${viewBoxWidth} ${viewBoxHeight}`}\n\t\t\t\taria-label={svgTitle}\n\t\t\t\tpreserveAspectRatio=\"xMidYMid meet\"\n\t\t\t\tstyle={{ overflow: 'visible' }}\n\t\t\t\tshapeRendering=\"geometricPrecision\"\n\t\t\t\tonPointerLeave={handlePointerLeave}\n\t\t\t\t{...(trimmedAriaLabel\n\t\t\t\t\t? { role: 'img', 'aria-labelledby': svgTitleId }\n\t\t\t\t\t: { role: 'img', 'aria-hidden': true })}\n\t\t\t>\n\t\t\t\t<rect width=\"100%\" height=\"100%\" fill=\"transparent\" />\n\t\t\t\t<g>\n\t\t\t\t\t{showGrid ? (\n\t\t\t\t\t\t<g stroke=\"currentColor\" strokeOpacity={0.1} strokeWidth={1}>\n\t\t\t\t\t\t\t{yAxisTicks.map((tick) => (\n\t\t\t\t\t\t\t\t<line\n\t\t\t\t\t\t\t\t\tkey={`grid-y-${tick.value}`}\n\t\t\t\t\t\t\t\t\tx1={chartStartX}\n\t\t\t\t\t\t\t\t\ty1={tick.position}\n\t\t\t\t\t\t\t\t\tx2={chartRight}\n\t\t\t\t\t\t\t\t\ty2={tick.position}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t) : null}\n\t\t\t\t\t{computedSeries.map((seriesItem) => (\n\t\t\t\t\t\t<g key={`series-${seriesItem.id}`}>\n\t\t\t\t\t\t\t{seriesItem.linePath ? (\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td={seriesItem.linePath}\n\t\t\t\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\t\t\t\tstroke={seriesItem.color}\n\t\t\t\t\t\t\t\t\tstrokeWidth={2}\n\t\t\t\t\t\t\t\t\tstrokeLinejoin=\"round\"\n\t\t\t\t\t\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t) : null}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t))}\n\t\t\t\t\t<g className=\"text-[10px] font-normal text-foreground/45\">\n\t\t\t\t\t\t{showXAxisLabels\n\t\t\t\t\t\t\t? xAxisTicks.map((tick) => (\n\t\t\t\t\t\t\t\t\t<g key={`axis-x-${tick.id}`}>\n\t\t\t\t\t\t\t\t\t\t<text\n\t\t\t\t\t\t\t\t\t\t\tx={tick.position}\n\t\t\t\t\t\t\t\t\t\t\ty={Math.min(\n\t\t\t\t\t\t\t\t\t\t\t\tviewBoxHeight + 4,\n\t\t\t\t\t\t\t\t\t\t\t\tchartBottom + axisTickLength + 20,\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\ttextAnchor=\"middle\"\n\t\t\t\t\t\t\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"text-[11px]\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{tick.label}\n\t\t\t\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t: null}\n\t\t\t\t\t\t{showYAxisLabels\n\t\t\t\t\t\t\t? yAxisTicks.map((tick) => (\n\t\t\t\t\t\t\t\t\t<g key={`axis-y-${tick.value}-${Math.round(tick.position)}`}>\n\t\t\t\t\t\t\t\t\t\t<text\n\t\t\t\t\t\t\t\t\t\t\tdata-line-chart-y-label\n\t\t\t\t\t\t\t\t\t\t\tx={yTickLabelX}\n\t\t\t\t\t\t\t\t\t\t\ty={tick.position + 3}\n\t\t\t\t\t\t\t\t\t\t\ttextAnchor=\"end\"\n\t\t\t\t\t\t\t\t\t\t\tfill=\"currentColor\"\n\t\t\t\t\t\t\t\t\t\t\tclassName=\"text-[11px]\"\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t{tick.label}\n\t\t\t\t\t\t\t\t\t\t</text>\n\t\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t: null}\n\t\t\t\t\t</g>\n\t\t\t\t\t{showDots\n\t\t\t\t\t\t? computedSeries.flatMap((seriesItem) =>\n\t\t\t\t\t\t\t\tseriesItem.positionedPoints.map(({ point, x, y }) => {\n\t\t\t\t\t\t\t\t\tconst isActive =\n\t\t\t\t\t\t\t\t\t\tactivePointId === point.id ||\n\t\t\t\t\t\t\t\t\t\t(activePointX !== null && point.x === activePointX);\n\t\t\t\t\t\t\t\t\tconst formattedXNode = formatX(point);\n\t\t\t\t\t\t\t\t\tconst formattedYNode = formatYForSeries(seriesItem.id, point);\n\t\t\t\t\t\t\t\t\tconst formattedXText = toPlainText(\n\t\t\t\t\t\t\t\t\t\tformattedXNode,\n\t\t\t\t\t\t\t\t\t\tgetPointLabelText(point),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst formattedYText = toPlainText(\n\t\t\t\t\t\t\t\t\t\tformattedYNode,\n\t\t\t\t\t\t\t\t\t\tgetPointValueText(point),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t<g key={`${seriesItem.id}-${point.id}`}>\n\t\t\t\t\t\t\t\t\t\t\t{/* biome-ignore lint/a11y/useSemanticElements: A <circle> cannot be replaced with <button> inside SVG, so we provide button semantics via role. */}\n\t\t\t\t\t\t\t\t\t\t\t<circle\n\t\t\t\t\t\t\t\t\t\t\t\tcx={x}\n\t\t\t\t\t\t\t\t\t\t\t\tcy={y}\n\t\t\t\t\t\t\t\t\t\t\t\tr={isActive ? 5 : 4}\n\t\t\t\t\t\t\t\t\t\t\t\tfill={seriesItem.color}\n\t\t\t\t\t\t\t\t\t\t\t\tfillOpacity={isActive ? 1 : 0}\n\t\t\t\t\t\t\t\t\t\t\t\tstroke={seriesItem.color}\n\t\t\t\t\t\t\t\t\t\t\t\tstrokeOpacity={isActive ? 1 : 0}\n\t\t\t\t\t\t\t\t\t\t\t\tstrokeWidth={0.5}\n\t\t\t\t\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\t\t\t\t\topacity: isActive ? 1 : 0,\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\trole=\"button\"\n\t\t\t\t\t\t\t\t\t\t\t\ttabIndex={0}\n\t\t\t\t\t\t\t\t\t\t\t\taria-pressed={isActive}\n\t\t\t\t\t\t\t\t\t\t\t\taria-label={`${seriesItem.seriesLabel} ${formattedXText}: ${formattedYText}`}\n\t\t\t\t\t\t\t\t\t\t\t\tonPointerEnter={() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateTooltipForPoint(seriesItem, point, { x, y })\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonPointerLeave={(event) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tevent.pointerType === 'touch' ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tevent.pointerType === 'pen'\n\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tscheduleTooltipHide();\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\tonFocus={() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateTooltipForPoint(seriesItem, point, { x, y })\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonBlur={clearTooltip}\n\t\t\t\t\t\t\t\t\t\t\t\tonClick={() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateTooltipForPoint(seriesItem, point, { x, y })\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tonKeyDown={(event) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (event.key === 'Enter' || event.key === ' ') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tupdateTooltipForPoint(seriesItem, point, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (event.key === 'Escape') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclearTooltip();\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: null}\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={chartStartX}\n\t\t\t\t\t\ty={padding.top}\n\t\t\t\t\t\twidth={chartWidth}\n\t\t\t\t\t\theight={chartHeight}\n\t\t\t\t\t\tfill=\"transparent\"\n\t\t\t\t\t\tonPointerMove={handlePointerMove}\n\t\t\t\t\t\tonPointerLeave={handlePointerLeave}\n\t\t\t\t\t\tonPointerDown={(event) => {\n\t\t\t\t\t\t\tif (event.pointerType === 'touch') {\n\t\t\t\t\t\t\t\thandlePointerMove(event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\t\t\t</svg>\n\t\t);\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tref={combinedRef}\n\t\t\tclassName={cn('relative w-full p-4', className)}\n\t\t\tstyle={{ ...style, height: resolvedHeight, minHeight: resolvedHeight }}\n\t\t\t{...rest}\n\t\t>\n\t\t\t<div\n\t\t\t\tref={(node) => {\n\t\t\t\t\tchartContainerRef.current = node;\n\t\t\t\t}}\n\t\t\t\tclassName=\"relative h-full w-full\"\n\t\t\t>\n\t\t\t\t{body}\n\t\t\t\t{showChart && children ? (\n\t\t\t\t\t<div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t\t{showTooltip && tooltip && renderTooltip ? (\n\t\t\t\t\t<div\n\t\t\t\t\t\tref={tooltipRef}\n\t\t\t\t\t\tdata-visible={tooltip.visible ? '' : undefined}\n\t\t\t\t\t\tclassName=\"pointer-events-none absolute left-0 top-0 z-50\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\ttransformOrigin: `${tooltip.horizontal} ${tooltip.vertical}`,\n\t\t\t\t\t\t\ttransform: `translate3d(${tooltip.x}px, ${tooltip.y}px, 0) scale(${tooltip.visible ? 1 : 0.95})`,\n\t\t\t\t\t\t\topacity: tooltip.visible ? 1 : 0,\n\t\t\t\t\t\t\ttransition:\n\t\t\t\t\t\t\t\t'transform 450ms var(--ease-smooth), opacity 300ms var(--ease-smooth)',\n\t\t\t\t\t\t\twillChange: 'transform, opacity',\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<div className=\"relative min-w-32 max-w-xs rounded-md border border-border bg-popover p-2 text-xs text-foreground shadow-md card-highlight\">\n\t\t\t\t\t\t\t{renderTooltip}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t) : null}\n\t\t\t</div>\n\t\t</div>\n\t);\n});\nLineChartGraphBase.displayName = 'LineChartGraph';\n\ntype LineChartGraphComponent = <TData extends ChartDatum = ChartDatum>(\n\tprops: LineChartGraphProps<TData> & { ref?: React.Ref<HTMLDivElement> },\n) => React.ReactElement | null;\n\nexport const LineChartGraph = LineChartGraphBase as LineChartGraphComponent;\n\nexport interface LineChartLegendProps\n\textends React.HTMLAttributes<HTMLDivElement> {}\n\nexport const LineChartLegend = React.forwardRef<\n\tHTMLDivElement,\n\tLineChartLegendProps\n>(({ className, ...props }, ref) => {\n\tconst { series } = useLineChartContext();\n\n\tif (!series.length) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t'flex flex-wrap items-center gap-3 px-4 pb-4 pt-2 text-xs text-foreground/70',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{series.map((seriesItem) => (\n\t\t\t\t<div key={seriesItem.id} className=\"flex items-center gap-2\">\n\t\t\t\t\t<span\n\t\t\t\t\t\tclassName=\"inline-flex h-2.5 w-1 shrink-0 rounded-[1px]\"\n\t\t\t\t\t\tstyle={{ backgroundColor: seriesItem.color }}\n\t\t\t\t\t/>\n\t\t\t\t\t<span className=\"text-xs font-medium text-foreground\">\n\t\t\t\t\t\t{seriesItem.seriesLabel}\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t))}\n\t\t</div>\n\t);\n});\nLineChartLegend.displayName = 'LineChartLegend';\n\nexport interface LineChartDataTableProps\n\textends React.HTMLAttributes<HTMLDivElement> {\n\tchildren: React.ReactNode;\n\tclassName?: string;\n}\n\nexport const LineChartDataTable = React.forwardRef<\n\tHTMLDivElement,\n\tLineChartDataTableProps\n>(({ className = '', children, ...props }, ref) => {\n\treturn (\n\t\t<div\n\t\t\tref={ref}\n\t\t\tclassName={cn(\n\t\t\t\t'bg-card-muted/30 space-y-2 border-t border-border/60 p-4 text-xs text-foreground/70',\n\t\t\t\tclassName,\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{children}\n\t\t</div>\n\t);\n});\nLineChartDataTable.displayName = 'LineChartDataTable';\n\nexport interface LineChartDataTableContentProps<\n\tTData extends ChartDatum = ChartDatum,\n> {\n\tclassName?: string;\n\trowClassName?: string;\n\tlabelClassName?: string;\n\tvalueClassName?: string;\n\tdeltaClassName?: string;\n\tshowDelta?: boolean;\n\tdeltaFormatter?: (\n\t\tcurrent: LineChartPoint<TData>,\n\t\tprevious: LineChartPoint<TData> | null,\n\t) => React.ReactNode;\n\tvalueFormatter?: (\n\t\tpoint: LineChartPoint<TData>,\n\t\tmeta: { total: number; domain: [number, number] },\n\t) => React.ReactNode;\n\tshowTotalRow?: boolean;\n\taverageLabel?: React.ReactNode;\n\taverageFormatter?: (average: number) => React.ReactNode;\n}\n\nexport function LineChartDataTableContent<\n\tTData extends ChartDatum = ChartDatum,\n>({\n\tclassName = '',\n\trowClassName,\n\tlabelClassName,\n\tvalueClassName,\n\tdeltaClassName,\n\tshowDelta = true,\n\tdeltaFormatter,\n\tvalueFormatter,\n\tshowTotalRow = true,\n\taverageLabel = 'Average',\n\taverageFormatter,\n}: LineChartDataTableContentProps<TData>) {\n\tconst { points, total, formatX, formatY, yDomain } =\n\t\tuseLineChartContext<TData>();\n\n\tif (!points.length) {\n\t\treturn null;\n\t}\n\n\tconst average = total / points.length;\n\n\tconst baseRowClass = showDelta\n\t\t? 'grid grid-cols-[minmax(0,1fr)_auto_auto] items-center gap-3'\n\t\t: 'grid grid-cols-[minmax(0,1fr)_auto] items-center gap-3';\n\n\ttype DeltaTone = 'positive' | 'negative' | 'neutral' | 'custom';\n\n\tconst formatDeltaPercentage = (ratio: number) => {\n\t\tconst absoluteRatio = Math.abs(ratio);\n\t\tconst maximumFractionDigits = absoluteRatio >= 100 ? 0 : 1;\n\t\tconst minimumFractionDigits =\n\t\t\tabsoluteRatio > 0 && absoluteRatio < 1 ? 1 : 0;\n\t\tconst formattedMagnitude = absoluteRatio.toLocaleString(undefined, {\n\t\t\tmaximumFractionDigits,\n\t\t\tminimumFractionDigits,\n\t\t});\n\t\tconst prefix = ratio > 0 ? '+' : ratio < 0 ? '' : '';\n\t\treturn `${prefix}${formattedMagnitude}%`;\n\t};\n\n\tconst resolveDeltaToneClass = (tone: DeltaTone) =>\n\t\ttone === 'positive'\n\t\t\t? 'text-success/90'\n\t\t\t: tone === 'negative'\n\t\t\t\t? 'text-destructive/90'\n\t\t\t\t: 'text-foreground/45';\n\n\tconst rows = points.map((point: LineChartPoint<TData>, index) => {\n\t\tconst previous = index > 0 ? (points[index - 1] ?? null) : null;\n\t\tconst resolvedValue = valueFormatter\n\t\t\t? valueFormatter(point, { total, domain: yDomain })\n\t\t\t: formatY(point);\n\t\tconst delta: {\n\t\t\tcontent: React.ReactNode;\n\t\t\ttone: DeltaTone;\n\t\t\tratio: number | null;\n\t\t} = (() => {\n\t\t\tif (!showDelta) {\n\t\t\t\treturn { content: null, tone: 'neutral', ratio: null };\n\t\t\t}\n\t\t\tif (deltaFormatter) {\n\t\t\t\treturn {\n\t\t\t\t\tcontent: deltaFormatter(point, previous),\n\t\t\t\t\ttone: 'custom',\n\t\t\t\t\tratio: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!previous ||\n\t\t\t\t!Number.isFinite(previous.value) ||\n\t\t\t\tprevious.value === 0\n\t\t\t) {\n\t\t\t\treturn { content: '', tone: 'neutral', ratio: null };\n\t\t\t}\n\t\t\tconst change = point.value - previous.value;\n\t\t\tconst ratio = (change / Math.abs(previous.value)) * 100;\n\t\t\tif (!Number.isFinite(ratio)) {\n\t\t\t\treturn { content: '', tone: 'neutral', ratio: null };\n\t\t\t}\n\t\t\tconst tone =\n\t\t\t\tratio > 0\n\t\t\t\t\t? ('positive' as const)\n\t\t\t\t\t: ratio < 0\n\t\t\t\t\t\t? ('negative' as const)\n\t\t\t\t\t\t: ('neutral' as const);\n\t\t\treturn {\n\t\t\t\tcontent: formatDeltaPercentage(ratio),\n\t\t\t\ttone,\n\t\t\t\tratio,\n\t\t\t};\n\t\t})();\n\n\t\treturn {\n\t\t\tpoint,\n\t\t\tresolvedValue,\n\t\t\tdelta,\n\t\t};\n\t});\n\n\tconst { sum: deltaSum, count: deltaCount } = showDelta\n\t\t? rows.reduce<{ sum: number; count: number }>(\n\t\t\t\t(acc, row) => {\n\t\t\t\t\tif (row.delta.ratio !== null) {\n\t\t\t\t\t\tacc.sum += row.delta.ratio;\n\t\t\t\t\t\tacc.count += 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{ sum: 0, count: 0 },\n\t\t\t)\n\t\t: { sum: 0, count: 0 };\n\n\tconst averageDelta =\n\t\tshowDelta && deltaCount > 0 ? deltaSum / deltaCount : null;\n\n\tconst averageDeltaTone =\n\t\taverageDelta !== null\n\t\t\t? averageDelta > 0\n\t\t\t\t? ('positive' as const)\n\t\t\t\t: averageDelta < 0\n\t\t\t\t\t? ('negative' as const)\n\t\t\t\t\t: ('neutral' as const)\n\t\t\t: ('neutral' as const);\n\n\tconst averageDeltaContent =\n\t\tshowDelta && averageDelta !== null\n\t\t\t? formatDeltaPercentage(averageDelta)\n\t\t\t: showDelta\n\t\t\t\t? ''\n\t\t\t\t: null;\n\n\treturn (\n\t\t<div className={cn('space-y-2', className)}>\n\t\t\t{rows.map(({ point, resolvedValue, delta }) => {\n\t\t\t\treturn (\n\t\t\t\t\t<div key={point.id} className={cn(baseRowClass, rowClassName)}>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t'flex items-center gap-2 text-foreground/70',\n\t\t\t\t\t\t\t\tlabelClassName,\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span className=\"truncate text-sm font-medium\">\n\t\t\t\t\t\t\t\t{formatX(point)}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t'inline-flex min-w-10 justify-end whitespace-nowrap text-right text-sm font-medium text-foreground/70 tabular-nums',\n\t\t\t\t\t\t\t\tvalueClassName,\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{resolvedValue}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t{showDelta ? (\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t'inline-flex min-w-14 justify-end whitespace-nowrap text-right text-xs uppercase tracking-wide tabular-nums',\n\t\t\t\t\t\t\t\t\tresolveDeltaToneClass(delta.tone),\n\t\t\t\t\t\t\t\t\tdeltaClassName,\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{delta.content}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t) : null}\n\t\t\t\t\t</div>\n\t\t\t\t);\n\t\t\t})}\n\t\t\t{showTotalRow ? (\n\t\t\t\t<div\n\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\tshowDelta\n\t\t\t\t\t\t\t? 'grid grid-cols-[minmax(0,1fr)_auto_auto] items-center gap-3 border-t border-border/60 pt-3 text-sm font-medium text-foreground'\n\t\t\t\t\t\t\t: 'grid grid-cols-[minmax(0,1fr)_auto] items-center gap-3 border-t border-border/60 pt-3 text-sm font-medium text-foreground',\n\t\t\t\t\t\trowClassName,\n\t\t\t\t\t)}\n\t\t\t\t>\n\t\t\t\t\t<span>{averageLabel}</span>\n\t\t\t\t\t<span\n\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t'inline-flex min-w-10 justify-end whitespace-nowrap text-right tabular-nums',\n\t\t\t\t\t\t\tvalueClassName,\n\t\t\t\t\t\t)}\n\t\t\t\t\t>\n\t\t\t\t\t\t{averageFormatter?.(average) ??\n\t\t\t\t\t\t\taverage.toLocaleString(undefined, { maximumFractionDigits: 2 })}\n\t\t\t\t\t</span>\n\t\t\t\t\t{showDelta ? (\n\t\t\t\t\t\t<span\n\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t'inline-flex min-w-14 justify-end whitespace-nowrap text-right text-xs uppercase tracking-wide tabular-nums',\n\t\t\t\t\t\t\t\tresolveDeltaToneClass(averageDeltaTone),\n\t\t\t\t\t\t\t\tdeltaClassName,\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{averageDeltaContent}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t) : null}\n\t\t\t\t</div>\n\t\t\t) : null}\n\t\t</div>\n\t);\n}\n\nexport const LineChart = LineChartRoot;\n",
      "type": "registry:component"
    }
  ]
}