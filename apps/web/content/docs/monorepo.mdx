---
title: Monorepo Setup
description: Link a shared Nocta UI workspace to an application using Bun workspaces.
---

import { Step, Steps } from 'fumadocs-ui/components/steps';

Nocta UI treats shared UI workspaces as the source of truth for component files. In a monorepo you can run CLI commands from an application workspace while the actual React source lives inside a sibling package. This guide recreates the Bun + Next.js example step by step so you can adapt it to your own tooling.

## Prerequisites
- Bun 1.1 or newer
- Node.js (for occasional `npx` utilities)
- Git (recommended for tracking generated files)

## Repository Layout

```
nocta-bun-monorepo
├── apps/
│   └── web     (Next.js application)
└── packages/
    └── ui      (shared Nocta UI workspace)
```

## Step-by-step

<Steps>
  <Step>
    ### 1. Initialise the repo root

   ```bash lineNumbers title="Terminal"
    mkdir nocta-bun-monorepo
    cd nocta-bun-monorepo
    bun init --yes
    ```

    Update `package.json` so Bun knows where workspaces live:

    ```json lineNumbers title="package.json"
    {
      "name": "nocta-bun-monorepo",
      "module": "index.ts",
      "type": "module",
      "private": true,
      "workspaces": ["apps/*", "packages/*"],  // [!code highlight]
      "devDependencies": {
        "@types/bun": "latest"
      },
      "peerDependencies": {
        "typescript": "^5"
      }
    }
    ```
  </Step>
  <Step>
    ### 2. Scaffold the shared UI workspace (`packages/ui`)

    ```bash lineNumbers title="Terminal"
    mkdir -p packages/ui
    cd packages/ui
    bun init --yes
    bun add -D tsc-alias rimraf concurrently tailwindcss
    ```

    Configure TypeScript with alias support so registry files that import from `@/...` compile cleanly:

    ```json lineNumbers title="tsconfig.json"
    {
      "compilerOptions": {
        "lib": ["ESNext","DOM"],
        "target": "ESNext",
        "module": "Preserve",
        "moduleDetection": "force",
        "jsx": "react-jsx",
        "allowJs": true,
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": false,   // [!code highlight]
        "verbatimModuleSyntax": false,  // [!code highlight]
        "outDir": "dist",   // [!code highlight]
        "declaration": true,   // [!code highlight]
        "declarationDir": "dist",   // [!code highlight]
        "baseUrl": ".",   // [!code highlight]
        "paths": {   // [!code highlight]
          "@/*": ["./src/*"]   // [!code highlight]
        },   // [!code highlight]
        "strict": true,
        "skipLibCheck": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "noImplicitOverride": true,
        "noUnusedLocals": false,
        "noUnusedParameters": false,
        "noPropertyAccessFromIndexSignature": false
      }
    }
    ```

    Add build scripts so the package emits compiled artefacts to `dist/`:

    ```json lineNumbers title="package.json"
    {
      "name": "ui",
      "type": "module",
      "private": true,
      "files": ["dist"],   // [!code highlight]
      "exports": {   // [!code highlight]
        ".": {   // [!code highlight]
          "import": "./dist/src/index.js",   // [!code highlight]
          "types": "./dist/src/index.d.ts"   // [!code highlight]
        },   // [!code highlight]
        "./dist/styles.css": "./dist/styles.css"   // [!code highlight]
      },   // [!code highlight]
      "main": "./dist/src/index.js",   // [!code highlight]
      "module": "./dist/src/index.js",   // [!code highlight]
      "types": "./dist/src/index.d.ts",   // [!code highlight]
      "peerDependencies": {
        "typescript": "^5.9.3"
      },
      "devDependencies": {
        "@types/bun": "latest",
        "concurrently": "^9.2.1",
        "rimraf": "^6.0.1",
        "tailwindcss": "^4.1.15",
        "tsc-alias": "^1.8.16",
        "typescript": "^5.9.3"
      },
      "scripts": {   // [!code highlight]
        "build": "bun run clean && bun run build:css && bun run build:ts",   // [!code highlight]
        "build:css": "mkdir -p dist && bunx tailwindcss --input src/styles.css --output dist/styles.css --minify",   // [!code highlight]
        "build:ts": "tsc -p tsconfig.json && tsc-alias -p tsconfig.json",   // [!code highlight]
        "clean": "rimraf dist",   // [!code highlight]
        "dev": "concurrently -k -n TS,ALIAS,CSS \"bun run dev:ts\" \"bun run dev:alias\" \"bun run dev:css\"",   // [!code highlight]
        "dev:ts": "tsc -w -p tsconfig.json",   // [!code highlight]
        "dev:alias": "tsc-alias -w -p tsconfig.json",   // [!code highlight]
        "dev:css": "bunx tailwindcss --input src/styles.css --output dist/styles.css --watch"   // [!code highlight]
      }   // [!code highlight]
    }
    ```

    `tsc-alias` rewrites the `@/...` imports in the compiled output so downstream apps can resolve files without custom TS paths.
  </Step>
  <Step>
    ### 3. Set up the Next.js app (`apps/web`)

   ```bash lineNumbers title="Terminal"
    cd ../../
    mkdir -p apps/web
    cd apps/web
    bun create next-app@latest . --yes
    ```

    Point the app at the shared workspace via Bun workspaces:

    ```json lineNumbers title="package.json"
    {
      "name": "web",
      "version": "0.1.0",
      "private": true,
      "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "eslint"
      },
      "dependencies": {
        "next": "16.0.0",
        "react": "19.2.0",
        "react-dom": "19.2.0",
        "ui": "workspace:*"   // [!code highlight]
      },
      "devDependencies": {
        "@tailwindcss/postcss": "^4",
        "@types/node": "^20",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "eslint": "^9",
        "eslint-config-next": "16.0.0",
        "tailwindcss": "^4",
        "typescript": "^5"
      }
    }
    ```

    Import the compiled UI stylesheet once inside `app/layout.tsx` (or your preferred root file):

    ```tsx lineNumbers title="app/layout.tsx"
    import "ui/dist/styles.css";
    ```
  </Step>
  <Step>
    ### 4. Initialise the Nocta CLI

    Run `init` inside each workspace so the CLI records relationships and writes helpers.

    ```bash lineNumbers title="Terminal"
    cd packages/ui
    npx @nocta-ui/cli init                # choose Shared UI

    cd ../../apps/web
    npx @nocta-ui/cli init                # choose Application and link "ui"
    ```

    - The shared UI workspace receives `nocta.config.json`, helper utilities, Tailwind tokens, and an entry inside `nocta.workspace.json`.
    - The application workspace stores a link to `ui`, so future `nocta-ui add` runs from `apps/web` copy React source into `packages/ui`.
  </Step>
  <Step>
    ### 5. Install components and rebuild the shared package

    From `apps/web` install components like normal:

    ```bash lineNumbers title="Terminal"
    npx @nocta-ui/cli add button card
    ```

    The CLI writes component source files into `packages/ui/src/...`, updates export barrels, and scopes dependency installs to the owning workspace. Rebuild or watch the shared package after each run so the compiled artefacts remain fresh:

    ```bash lineNumbers title="Terminal"
    bun run --filter ui build
    # or keep everything hot
    bun run --filter ui dev
    ```
  </Step>
</Steps>

## Using the Components

After rebuilding, import components from the shared package inside your application:

```tsx lineNumbers title="apps/web/app/page.tsx"
import { Button } from "ui";

export default function Page() {
  return <Button>Ready for launch</Button>;
}
```

You now have a monorepo-aware workflow where shared UI code lives in `packages/ui`, applications call CLI commands from their own directory, and Bun handles dependencies for the entire workspace.
